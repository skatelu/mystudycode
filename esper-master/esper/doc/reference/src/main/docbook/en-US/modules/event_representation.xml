<chapter xml:id="event_representation" version="5.0"
         xsi:schemaLocation="http://docbook.org/ns/docbook http://www.docbook.org/xml/5.0/xsd/docbook.xsd http://www.w3.org/1999/xlink http://www.docbook.org/xml/5.0/xsd/xlink.xsd"
         xml:base="./" xmlns="http://docbook.org/ns/docbook" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:ns="http://docbook.org/ns/docbook">

    <title>Event Representations</title>
    
    <para>
		This section outlines the different means to model and represent events.
    </para>

	<para>
		Esper uses the term <emphasis>event type</emphasis> to describe the type information available for an event representation.
	</para>
	
	<para>
	    Your application may configure predefined event types at startup time or dynamically add event types at runtime via API or EPL syntax. See <xref linkend="configuration-items"/> for startup-time configuration and <xref linkend="api-admin-runtime-config"/> for the runtime configuration API.
	</para>

	<para>
	    The EPL <literal>create schema</literal> syntax allows declaring an event type at runtime using EPL, see <xref linkend="epl_createschema"/>.
	</para>

    <para>
		<xref linkend="api-event"/> explains how an event type becomes visible in EPL statements and output events delivered by the engine.
    </para>

    <sect1 xml:id="eventrep_intro">
        <title>Event Underlying Java Objects</title>

		<indexterm><primary>event</primary><secondary>underlying representation</secondary></indexterm>
        <para>
			An event is an immutable record of a past occurrence of an action or state change. Event properties capture the state information for an event.
        </para>

        <para>
			In Esper, an event can be represented by any of the following underlying Java objects (NEsper .NET, see <xref linkend="appendix_dotnet_eventrep_intro"/>):
        </para>
        
		<table frame="topbot">
			<title>Event Underlying Java Objects</title>
			<tgroup cols="2">
				<colspec colwidth="1.5*"/>
				<colspec colwidth="2*"/>
				<thead>
					<row>
						<entry>Java Class</entry>
						<entry>Description</entry>
					</row>
				</thead>
				<tbody>
					<row>
						<entry><literal>java.lang.Object</literal></entry>
						<entry>Any Java POJO (plain-old java object) with getter methods following JavaBean conventions;  Legacy Java classes not following JavaBean conventions can also serve as events .</entry>
					</row>
					<row>
						<entry><literal>java.util.Map</literal></entry>
						<entry>Map events are implementations of the <literal>java.util.Map</literal> interface where each map entry is a propery value.</entry>
					</row>
					<row>
						<entry><literal>Object[] (array of object)</literal></entry>
						<entry>Object-array events are arrays of objects (type <literal>Object[]</literal>) where each array element is a property value.</entry>
					</row>
					<row>
						<entry><literal>org.apache.avro.generic.GenericData.Record</literal></entry>
						<entry>Apache Avro events are <literal>GenericData.Record</literal> objects (Avro is a data serialization system with JSON and schema support)</entry>
					</row>
					<row>
						<entry><literal>org.w3c.dom.Node</literal></entry>
						<entry>XML document object model (DOM).</entry>
					</row>
					<row>
						<entry><literal>org.apache.axiom.om.OMDocument or OMElement</literal></entry>
						<entry>XML - Streaming API for XML (StAX) - Apache Axiom (provided by EsperIO package).</entry>
					</row>
					<row>
						<entry>Application classes</entry>
						<entry>Plug-in event representation via the extension API.</entry>
					</row>
				</tbody>
			</tgroup>
		</table>
		
		<para>
			Esper provides multiple choices for representing an event. There is no absolute need for you to create new Java classes to represent an event.
		</para>
		
		<para>
			Event representations have the following in common:
		</para>
		
		<itemizedlist spacing="compact">
			<listitem>
				<para>
					All event representations support nested, indexed and mapped properties (aka. property expression), as explained in more detail below. There is no limitation to the nesting level.
				</para>
			</listitem>
			<listitem>
				<para>
					All event representations provide event type metadata. This includes type metadata for nested properties.
				</para>
			</listitem>
			<listitem>
				<para>
					All event representations allow transposing the event itself and parts or all of its property graph into new events. The term transposing refers to selecting the event itself or event properties that are themselves nestable property graphs, and then querying the event's properties or nested property graphs in further statements. The Apache Axiom event representation is an exception and does not currently allow transposing event properties but does allow transposing the event itself.
				</para>
			</listitem>
			<listitem>
				<para>
					The Java object, Map, Object-array and Avro representations allow supertypes.
				</para>
			</listitem>
		</itemizedlist>

		<para>
			The API behavior for all event representations is the same, with minor exceptions noted. 
		</para>

		<para>
			The benefits of multiple event representations are:
		</para>
		<itemizedlist spacing="compact">
			<listitem>
				<para>
					For applications that already have events in one of the supported representations, there is no need to transform events before processing for both input and output.
				</para>
			</listitem>
			<listitem>
				<para>
					Event representations are exchangeable, reducing or eliminating the need to change statements when the event representation changes, i.e. the EPL does not depend on whether events are Objects, Map(s), Object-array(s), Avro record(s) or XML document(s).
				</para>
			</listitem>
			<listitem>
				<para>
					Event representations are interoperable, allowing all event representations to interoperate in same or different statements.
				</para>
			</listitem>
			<listitem>
				<para>
					The choice makes it possible to consciously trade-off performance, ease-of-use, the ability to evolve and effort needed to import or externalize events and use existing event type metadata. 
				</para>
			</listitem>
		</itemizedlist>

	</sect1>

	<sect1 xml:id="eventrep-properties">
	   <title>Event Properties</title>
           
		<indexterm><primary>event</primary><secondary>properties</secondary></indexterm>
		<para>
			 Event properties capture the state information for an event. Event properties can be simple, indexed, mapped and nested event properties.
		</para>

		<para>
			 The table below outlines the different types of properties and their syntax in an event expression:
		</para>

		<table frame="topbot">
			<title>Types of Event Properties</title>
			<tgroup cols="4">
				<colspec colwidth="1*"/>
				<colspec colwidth="2.5*"/>
				<colspec colwidth="1.5*"/>
				<colspec colwidth="1.5*"/>
				<thead>
					<row>
						<entry>Type</entry>
						<entry>Description</entry>
						<entry>Syntax</entry>
						<entry>Example</entry>
					</row>
				</thead>
				<tbody>
					<row>
						<entry>Simple</entry>
						<entry>A property that has a single value that may be retrieved.</entry>
						<entry><synopsis>name</synopsis></entry>
						<entry><synopsis>sensorId</synopsis></entry>
					</row>
					<row>
						<entry>Indexed</entry>
						<entry>An indexed property stores an ordered collection of objects (all of the same type) that can be individually accessed by an integer-valued, non-negative index (or subscript).</entry>
						<entry><synopsis>name[<emphasis>index</emphasis>]</synopsis></entry>
						<entry><synopsis>temperature[0]</synopsis></entry>
					</row>
					<row>
						<entry>Mapped</entry>
						<entry>A mapped property stores a keyed collection of objects (all of the same type).</entry>
						<entry><synopsis>name('<emphasis>key</emphasis>')</synopsis></entry>
						<entry><synopsis>isTurnedOn('light')</synopsis></entry>
					</row>
					<row>
						<entry>Nested</entry>
						<entry>A nested property is a property that lives within another property of an event.</entry>
						<entry><synopsis>name.nestedname</synopsis></entry>
						<entry><synopsis>sensor.value</synopsis></entry>
					</row>
				</tbody>
			</tgroup>
		</table> 

		<para>
			Combinations are also possible. For example, a valid combination could be <literal>person.address('home').street[0]</literal>.
		</para>

		<para>
			You may use any expression as a mapped property key or indexed property index by putting the expression within parenthesis after the mapped or index property name. Please find examples below.
		</para>

		<sect2 xml:id="eventrep-properties-escaping">
		   <title>Escape Characters</title>
			<para>
				If your application uses <literal>java.util.Map</literal>, <literal>Object[]</literal> (object-array) or XML to represent events, then event property names may themselves contain the dot ('.') character. The backslash ('\') character can be used to escape dot characters in property names, allowing a property name to contain dot characters. 
			</para>
			
			<para>
				For example, the EPL as shown below expects a property by name <literal>part1.part2</literal> to exist on event type <literal>MyEvent</literal>:
			</para>
			<programlisting>select part1\.part2 from MyEvent</programlisting> 

			<para>
				Sometimes your event properties may overlap with EPL language keywords or contain spaces or other special characters. In this case you may use the backwards apostrophe <literal>`</literal> (aka. back tick) character to escape the property name.
			</para>
			
			<para>
				The next example assumes a <literal>Quote</literal> event that has a property by name <literal>order</literal>, while <literal>order</literal> is also a reserved keyword:
			</para>
			<programlisting>select `order`, price as `price.for.goods` from Quote</programlisting> 

			<para>
				When escaping mapped or indexed properties, make sure the back tick character appears outside of the map key or index.
			</para>

			<para>
				The next EPL selects event properties that have names that contain spaces (e.g. <literal>candidate book</literal>), have the tick special character  (e.g. <literal>children's books</literal>), are an indexed property (e.g. <literal>children's books[0]</literal>) and a mapped property 
				that has a reserved keyword as part of the property name (e.g. <literal>book select('isbn')</literal>):
			</para>
			<programlisting>select `candidate book` , `children's books`[0], `book select`('isbn') from MyEventType</programlisting> 
			
			<note>
				<para>
					Avro does not support the dot-character in field names.
				</para>
			</note>
  
		</sect2>

		<sect2 xml:id="eventrep-properties-expression">
		   <title>Expression as Key or Index Value</title>
	   
			<para>
				The key or index expression must be placed in parenthesis.  When using an expression as key for a mapped property, the expression must return a <literal>String</literal>-typed value. When using an expression as index for an indexed property, the expression must return an <literal>int</literal>-typed value.				
			</para>
	
			<para>
				This example below uses Java classes to illustrate; The same principles apply to all event representations.
			</para>

			<para>
				Assume a class declares these properties (getters not shown for brevity):
			</para>
			<programlisting><![CDATA[public class MyEventType {
  String myMapKey;
  int myIndexValue;
  int myInnerIndexValue;
  Map<String, InnerType> innerTypesMap;	// mapped property
  InnerType[] innerTypesArray; // indexed property
}

public class InnerType {
  String name;
  int[] ids;
}]]></programlisting>

			<para>
				A sample EPL statement demonstrating expressions as map keys or indexes is:
			</para>
			<programlisting><![CDATA[select innerTypesMap('somekey'),  // returns map value for 'somekey'
  innerTypesMap(myMapKey),        // returns map value for myMapKey value (an expression)
  innerTypesArray[1],             // returns array value at index 1
  innerTypesArray(myIndexValue)   // returns array value at index myIndexValue (an expression)
  from MyEventType]]></programlisting>

			<para>
				The dot-operator can be used to access methods on the value objects returned by the mapped or indexed properties. By using the dot-operator the syntax follows the chained method invocation described at <xref linkend="epl-operator-ref-dot"/>.
			</para>
	
			<para>
				A sample EPL statement demonstrating the dot-operator as well as expressions as map keys or indexes is:
			</para>
			<programlisting><![CDATA[ select innerTypesMap('somekey').ids[1],
  innerTypesMap(myMapKey).getIds(myIndexValue),
  innerTypesArray[1].ids[2],
  innerTypesArray(myIndexValue).getIds(myInnerIndexValue)
  from MyEventType]]></programlisting>
		
			 <para>
				Please note the following limitations:
			</para>
			<itemizedlist spacing="compact">
				<listitem>
					<para>
						The square brackets-syntax for indexed properties does now allow expressions and requires a constant index value.
					</para>
				</listitem>
				<listitem>
					<para>
						When using the dot-operator with mapped or indexed properties that have expressions as map keys or indexes you must follow the chained method invocation syntax.
					</para>
				</listitem>
			</itemizedlist>
		</sect2>
	</sect1>
		
	<sect1 xml:id="eventrep-dyncproperties">
	   <title>Dynamic Event Properties</title>
           
		<indexterm><primary>dynamic event properties</primary></indexterm>
		<indexterm><primary>event</primary><secondary>dynamic properties</secondary></indexterm>
		<para>
			Dynamic (unchecked) properties are event properties that need not be known at statement compilation time. Such properties are resolved during runtime: they provide duck typing functionality.
		</para>
			
		<para>
			The idea behind dynamic properties is that for a given underlying event representation you don't always know all properties in advance. An underlying event may have additional properties that are not known at statement compilation time, that you want to query on. The concept is especially useful for events that represent rich, object-oriented domain models.
		</para>

		<para>
			The syntax of dynamic properties consists of the property name and a question mark. Indexed, mapped and nested properties can also be dynamic properties:
		</para>

		<table frame="topbot">
			<title>Types of Event Properties</title>
			<tgroup cols="2">
				<colspec colwidth="1*"/>
				<colspec colwidth="2.5*"/>
				<thead>
					<row>
						<entry>Type</entry>
						<entry>Syntax</entry>
					</row>
				</thead>
				<tbody>
					<row>
						<entry>Dynamic Simple</entry>
						<entry><synopsis>name?</synopsis></entry>
					</row>
					<row>
						<entry>Dynamic Indexed</entry>
						<entry><synopsis>name[<emphasis>index</emphasis>]?</synopsis></entry>
					</row>
					<row>
						<entry>Dynamic Mapped</entry>
						<entry><synopsis>name('<emphasis>key</emphasis>')?</synopsis></entry>
					</row>
					<row>
						<entry>Dynamic Nested</entry>
						<entry><synopsis>name?.nestedPropertyName</synopsis></entry>
					</row>
				</tbody>
			</tgroup>
		</table> 

		<para>
			 Dynamic properties always return the <literal>java.lang.Object</literal> type. Also, dynamic properties return a <literal>null</literal> value if the dynamic property does not exist on events processed at runtime. 
		</para>

		<para>
			As an example, consider an OrderEvent event that provides an "item" property. The "item" property is of type <literal>Object</literal> and holds a reference to an instance of either a Service or Product. 
		</para>

		<para>
			Assume that both Service and Product classes provide a property named "price". Via a dynamic property you can specify a query that obtains the price property from either object (Service or Product):
		</para>
		<programlisting><![CDATA[select item.price? from OrderEvent]]></programlisting>		

		<para>
			 As a second example, assume that the Service class contains a "serviceName" property that the Product class does not possess. The following query returns the value of the "serviceName" property for Service objects. It returns a <literal>null</literal>-value for Product objects that do not have the "serviceName" property:
		</para>
		<programlisting><![CDATA[select item.serviceName? from OrderEvent]]></programlisting>		

		<para>
			Consider the case where OrderEvent has multiple implementation classes, some of which have a "timestamp" property. The next query returns the timestamp property of those implementations of the OrderEvent interface that feature the property:
		</para>
		<programlisting><![CDATA[select timestamp? from OrderEvent]]></programlisting>		
		
		<para>
			The query as above returns a single column named "timestamp?" of type <literal>Object</literal>. 			
		</para>

		<para>
			When dynamic properties are nested, then all properties under the dynamic property are also considered dynamic properties. In the below example the query asks for the "direction" property of the object returned by the "detail" dynamic property:
		</para>
		<programlisting><![CDATA[select detail?.direction from OrderEvent]]></programlisting>		
		<para>
			Above is equivalent to:
		</para>
		<programlisting><![CDATA[select detail?.direction? from OrderEvent]]></programlisting>		

		<para>
			The functions that are often useful in conjunction with dynamic properties are:
		</para>

		<itemizedlist>
			<listitem>
				<para>
                    The <literal>cast</literal> function casts the value of a dynamic property (or the value of an expression) to a given type.
                </para>
			</listitem>
			<listitem>
				<para>
                    The <literal>exists</literal> function checks whether a dynamic property exists. It returns <literal>true</literal> if the event has a property of that name, or false if the property does not exist on that event.
                </para>
			</listitem>
			<listitem>
				<para>
                    The <literal>instanceof</literal> function checks whether the value of a dynamic property (or the value of an expression) is of any of the given types.
                </para>
			</listitem>
			<listitem>
				<para>
                    The <literal>typeof</literal> function returns the string type name of a dynamic property.
                </para>
			</listitem>
		</itemizedlist>

		<para>
			Dynamic event properties work with all event representations outlined next: Java objects, Map-based, Object-array-based and XML DOM-based events.
		</para>

	</sect1>

	<sect1 xml:id="eventrep-fragment">
	   <title>Fragment and Fragment Type</title>
		<para>
			Sometimes an event can have properties that are itself events. Esper uses the term <emphasis>fragment</emphasis> and <emphasis>fragment type</emphasis> for such event pieces. The best example is a pattern
			that matches two or more events and the output event contains the matching events as fragments. In other words, output events can be a composite event that consists of further events, the fragments.
		</para>

		<para>
			Fragments have the same metadata available as their enclosing composite events. The metadata for enclosing composite events contains information about which properties are fragments, or have a property value that can be 
			represented as a fragment and therefore as an event itself.
		</para>

		<para>
			Fragments and type metadata can allow your application to navigate composite events without the need for using the Java reflection API and reducing the coupling to the underlying event representation.
			The API is further described in <xref linkend="api-event"/>.
		</para>		
	</sect1>

    <sect1 xml:id="eventrep_comparing">
        <title>Comparing Event Representations</title>

		<para>
			More information on event representations can be found in the appendix. The links are:
		</para>
        
		<table frame="topbot">
			<title>Comparing Event Representations</title>
			<tgroup cols="2">
				<colspec colwidth="1.5*"/>
				<colspec colwidth="1.5*"/>
				<thead>
					<row>
						<entry>Event Representation</entry>
						<entry>More Information and Examples</entry>
					</row>
				</thead>
				<tbody>
					<row>
						<entry>Java Object (POJO/Bean or other)</entry>
						<entry><xref linkend="appendix_eventrepbean"/></entry>
					</row>
					<row>
						<entry>Map</entry>
						<entry><xref linkend="appendix_eventrepmap"/></entry>
					</row>
					<row>
						<entry>Object-array</entry>
						<entry><xref linkend="appendix_eventrepoa"/></entry>
					</row>
					<row>
						<entry>Avro</entry>
						<entry><xref linkend="appendix_eventrepavro"/></entry>
					</row>
					<row>
						<entry>XML Document</entry>
						<entry><xref linkend="appendix_eventrepxml"/></entry>
					</row>
				</tbody>
			</tgroup>
		</table>        
		        
		<sect2 xml:id="eventrep_comparing_incoming">
			<title>Incoming Events</title>
			<para>
				For sending incoming events into the engine for processing, your application uses one of the send-event methods on the <literal>EPRuntime</literal> interface: 
			</para>
			<table frame="topbot">
				<title>EPRuntime Send-event Methods</title>
				<tgroup cols="2">
					<colspec colwidth="1.5*"/>
					<colspec colwidth="1.5*"/>
					<thead>
						<row>
							<entry>Event Representation</entry>
							<entry>Method for Processing Events</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>Java Object (POJO/Bean or other)</entry>
							<entry><programlisting>sendEvent(Object event)</programlisting></entry>
						</row>
						<row>
							<entry>Map</entry>
							<entry><programlisting>sendEvent(Map map, String mapEventTypeName)</programlisting></entry>
						</row>
						<row>
							<entry>Object-array</entry>
							<entry><programlisting>sendEvent(Object[] objectarray, String objectArrayEventTypeName)</programlisting></entry>
						</row>
						<row>
							<entry>Avro</entry>
							<entry><programlisting>sendEvent(Object avroGenericDataDotRecord, String avroEventTypeName)</programlisting></entry>
						</row>
						<row>
							<entry>XML Document</entry>
							<entry><programlisting>sendEvent(org.w3c.dom.Node node)</programlisting></entry>
						</row>
					</tbody>
				</tgroup>
			</table>        

			<para>
				Please find an example in the respective appendix.
			</para>
  		</sect2>

		<sect2 xml:id="eventrep_comparing_outgoing">
			<title>Outgoing Events</title>
			<para>
				The <literal>StatementUpdateListener</literal> interface receives EPL statement output. The output events can be either of the representations
			</para>
			<table frame="topbot">
				<title>Annotation for Receiving Events</title>
				<tgroup cols="2">
					<colspec colwidth="1.5*"/>
					<colspec colwidth="1.5*"/>
					<thead>
						<row>
							<entry>Event Representation</entry>
							<entry>Annotation</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>Java Object (POJO/Bean or other)</entry>
							<entry><programlisting>N/A</programlisting></entry>
						</row>
						<row>
							<entry>Map</entry>
							<entry><programlisting>@EventRepresentation(map)</programlisting></entry>
						</row>
						<row>
							<entry>Object-array</entry>
							<entry><programlisting>@EventRepresentation(objectarray)</programlisting></entry>
						</row>
						<row>
							<entry>Avro</entry>
							<entry><programlisting>@EventRepresentation(avro)</programlisting></entry>
						</row>
						<row>
							<entry>XML Document</entry>
							<entry><programlisting>N/A</programlisting></entry>
						</row>
					</tbody>
				</tgroup>
			</table>        
			
			<para>
				Please find an example in the respective appendix.
			</para>
		</sect2>

		<sect2 xml:id="eventrep_comparing_schema">
			<title>Schema</title>
			<para>
				The create-schema clause can be used to define an event type and its event representation.
			</para>
			<table frame="topbot">
				<title>Create-Schema</title>
				<tgroup cols="2">
					<colspec colwidth="1.5*"/>
					<colspec colwidth="1.5*"/>
					<thead>
						<row>
							<entry>Event Representation</entry>
							<entry>Annotation</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>Java Object (POJO/Bean or other)</entry>
							<entry><programlisting>create schema <emphasis>name</emphasis> as <emphasis>class_name</emphasis></programlisting></entry>
						</row>
						<row>
							<entry>Map</entry>
							<entry><programlisting>create map schema <emphasis>name</emphasis> as (...)</programlisting></entry>
						</row>
						<row>
							<entry>Object-array</entry>
							<entry><programlisting>create objectarray schema <emphasis>name</emphasis> as (...)</programlisting></entry>
						</row>
						<row>
							<entry>Avro</entry>
							<entry><programlisting>create avro schema <emphasis>name</emphasis> as (...)</programlisting></entry>
						</row>
						<row>
							<entry>XML Document</entry>
							<entry><programlisting>N/A</programlisting></entry>
						</row>
					</tbody>
				</tgroup>
			</table>        
			
			<para>
				Your EPL statements can use <literal>create schema</literal> and <literal>insert into</literal> to define an event type and to produce events of the type.
			</para>

			<para>
				In the following example the first statement declares a schema and the second statement inserts events according to the schema:
			</para>
			<programlisting><![CDATA[create map schema ParkingEvent as (carId string, driverName string)]]></programlisting>		
			<programlisting><![CDATA[insert into ParkingEvent select carId, 'jim' as driverName from CarArrivalEvent]]></programlisting>		

			<para>
				Please find additional examples in <xref linkend="epl_createschema"/>.
			</para>
		</sect2>

		<sect2 xml:id="eventrep_comparing_advantages">
			<title>Side-by-Side</title>
			<para>
				Each of the event representations of Java object, Map, Object-array, Avro and XML document has advantages and disadvantages that are summarized in the table below:
			</para>
			
			<table frame="topbot">
				<title>Comparing Event Representations</title>
				<tgroup cols="6">
					<colspec colwidth="1.5*"/>
					<colspec colwidth="1.5*"/>
					<colspec colwidth="1.5*"/>
					<colspec colwidth="1.5*"/>
					<colspec colwidth="1.5*"/>
					<colspec colwidth="1.5*"/>
					<thead>
						<row>
							<entry></entry>
							<entry>Java Object (POJO/Bean or other)</entry>
							<entry>Map</entry>
							<entry>Object-array</entry>
							<entry>Avro</entry>
							<entry>XML Document</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>Performance</entry>
							<entry>Very Good (with Byte Code Generation, else Good)</entry>
							<entry>Good</entry>
							<entry>Very Good</entry>
							<entry>Very Good</entry>
							<entry>Not comparable and depending on use of XPath</entry>
						</row>
						<row>
							<entry>Memory Use</entry>
							<entry>Small</entry>
							<entry>Medium</entry>
							<entry>Small</entry>
							<entry>Small</entry>
							<entry>Depends on DOM and XPath implementation used, can be large</entry>
						</row>
						<row>
							<entry>Call Method on Event</entry>
							<entry>Yes</entry>
							<entry>Yes, if contains Object(s)</entry>
							<entry>Yes, if contains Object(s)</entry>
							<entry>No</entry>
							<entry>No</entry>
						</row>
						<row>
							<entry>Nested, Indexed, Mapped and Dynamic Properties</entry>
							<entry>Yes</entry>
							<entry>Yes</entry>
							<entry>Yes</entry>
							<entry>Yes</entry>
							<entry>Yes</entry>
						</row>
						<row>
							<entry>Course-grained event syntax</entry>
							<entry>Yes</entry>
							<entry>Yes</entry>
							<entry>Yes</entry>
							<entry>Yes</entry>
							<entry>Yes</entry>
						</row>
						<row>
							<entry>Insert-into that Representation</entry>
							<entry>Yes</entry>
							<entry>Yes</entry>
							<entry>Yes</entry>
							<entry>Yes</entry>
							<entry>No</entry>
						</row>
						<row>
							<entry>Runtime Type Change</entry>
							<entry>Reload class, yes</entry>
							<entry>Yes</entry>
							<entry>Yes</entry>
							<entry>Yes</entry>
							<entry>Yes</entry>
						</row>
						<row>
							<entry>Create-schema Syntax</entry>
							<entry>Yes</entry>
							<entry>Yes</entry>
							<entry>Yes</entry>
							<entry>Yes</entry>
							<entry>No, runtime and static configuration</entry>
						</row>
						<row>
							<entry>Object is Self-Descriptive</entry>
							<entry>Yes</entry>
							<entry>Yes</entry>
							<entry>No</entry>
							<entry>Yes</entry>
							<entry>Yes</entry>
						</row>
						<row>
							<entry>Supertypes</entry>
							<entry>Multiple</entry>
							<entry>Multiple</entry>
							<entry>Single</entry>
							<entry>Single</entry>
							<entry>No</entry>
						</row>
					</tbody>
				</tgroup>
			</table>        
		 </sect2>
     </sect1>
       
	<sect1 xml:id="eventrep-generictuple">
	   <title>Support for Generic Tuples</title>
		   <para>
			   Esper does not require a fixed tuple structure and fully supports generic tuples. Event properties can be defined, added to existing types and queried at runtime.
		   </para>
		   
		   <para>
			 The facilities for support of generic tuples are:  
		   </para>
		   <itemizedlist>
				<ns:listitem>
					<para>Dynamic properties allow querying properties that are not defined, see <xref linkend="eventrep-dyncproperties"/>.</para>
				</ns:listitem>
				<ns:listitem>
					<para>The <literal>cast</literal> function for operations that require strongly-typed data, see <xref linkend="epl-single-row-function-cast"/>.</para>
				</ns:listitem>
				<ns:listitem>
					<para>Type inheritance for adding properties to supertypes, see <xref linkend="epl_createschema"/></para>
				</ns:listitem>
				<ns:listitem>
					<para>The Map event representation, as it allows any map key to become an event property, see <xref linkend="appendix_eventrepmap"/></para>
				</ns:listitem>
				<ns:listitem>
					<para>The Avro event representation, as it allows any Avro field to become an event property, see <xref linkend="appendix_eventrepavro"/></para>
				</ns:listitem>
				<ns:listitem>
					<para>The POJO event representation, as getter-methods and fields can be dynamically discovered to become an event property, see <xref linkend="appendix_eventrepbean"/></para>
				</ns:listitem>
				<ns:listitem>
					<para>The XML event representation, as the DOM can have any attribute or nested element and there does not need to be a schema, see <xref linkend="appendix_eventrepxml"/></para>
				</ns:listitem>
				<ns:listitem>
					<para>Event types can be updated at runtime using the API</para>
				</ns:listitem>
			</itemizedlist>
			
			<para>
				There is no need to explicitly create an event type for each tuple type. It is not necessary to create classes for tuple types at all. Events can be arbitrary objects.
			</para>

			<para>
				The engine validates EPL at statement creation time therefore there is an advantage if type information is available: the engine can verify your EPL statement against the known properties and types,
				preventing you as the EPL designer from making mistakes in EPL design.
				The engine does not verify dynamic properties, which may return <literal>null</literal> at runtime. 
				If type information is not available then properties are assumed to return <literal>java.lang.Object</literal>-typed values.
			</para>

			<para>
				For example, let's say you need a generic tuple and you have <literal>Map</literal> events:
			</para>
			<programlisting>create schema GenericTuple()</programlisting> 

			<para>
				Create statements that use dynamic properties, as the next EPL shows, which casts the timestamp value to a <literal>long</literal>-type value and outputs the hour-minute-second string:
			</para>
			<programlisting>select cast(timestamp?, long).format('hh mm ss') from GenericTuple</programlisting> 

			<para>
				Send events like this:
			</para>
			<programlisting><![CDATA[Map<String, Object> genericEvent = new HashMap<>();
genericEvent.put("timestamp", new Date().getTime());
genericEvent.put("some_other_property", "hello");
epService.getEPRuntime().sendEvent(genericEvent, "GenericTuple");]]></programlisting>
     </sect1>

	<sect1 xml:id="eventrep-plug-in">
	   <title>Additional Event Representations</title>
	   
		<indexterm><primary>event</primary><secondary>additional representations</secondary></indexterm>
		<para>
		    Part of the extension and plug-in features of Esper is an event representation API. This set of classes allow an application to create new event types and event instances based on information available elsewhere, statically or dynamically at runtime when EPL statements are created. Please see <xref linkend="custom-event-representation"/> for details.
		</para>
		    
		<para>
			Creating a plug-in event representation can be useful when your application has existing Java classes that carry event metadata and event property values and your application does not want to (or cannot) extract or transform
such event metadata and event data into one of the built-in event representations (POJO Java objects, Map, Object-array or XML DOM).
		</para>

		<para>
			Further use of a plug-in event representation is to provide a faster or short-cut access path to event data. For example, access to event data stored in a XML format through the Streaming API for XML (StAX) is known to be very efficient. A plug-in event representation can also provide network lookup and dynamic resolution of event type and dynamic sourcing of event instances.
		</para>
		
		<para>
			Currently, EsperIO provides the following additional event representations:
		</para>
		<itemizedlist spacing="compact">
			<listitem>
				<para>
					Apache Axiom: Streaming API for XML (StAX) implementation
				</para>
			</listitem>
		</itemizedlist>
		
		<para>
			Please see the EsperIO documentation for details on the above.
		</para>
		
		<para>
			The chapter on <xref linkend="custom-event-representation"/> explains how to create your own custom event representation.
		</para>
	</sect1>

	<sect1 xml:id="eventrep-update">
	   <title>Updating, Merging and Versioning Events</title>
	   
		<indexterm><primary>event</primary><secondary>update</secondary></indexterm>
		<indexterm><primary>event</primary><secondary>version</secondary></indexterm>

        <para>
			To summarize, an event is an immutable record of a past occurrence of an action or state change, and event properties contain useful information about an event.
        </para>

        <para>
			The length of time an event is of interest to the event processing engine (retention time) depends on your EPL statements, and especially the data window, pattern and output rate 
			limiting clauses of your statements.
        </para>

        <para>
			During the retention time of an event more information about the event may become available, such as additional properties or changes to existing properties. 
			Esper provides three concepts for handling updates to events.
        </para>
        
        <para>
			  The first means to handle updating events is the <literal>update istream</literal> clause as further described in <xref linkend="epl-update"/>. It is useful when you need to update events as they enter a stream, before events are evaluated by any particular 
			  consuming statement to that stream.
        </para>

        <para>
			  The second means to update events is the <literal>on-merge</literal> and <literal>on-update</literal> clauses, for use with tables and named windows only, as further described in <xref linkend="named_upsert"/> and <xref linkend="named_update"/>. On-merge
			  is similar to the SQL <literal>merge</literal> clause and provides what is known as an "Upsert" operation: Update existing events or if no existing event(s) are found then insert a new event, all in one atomic operation provided by a single EPL statement. 
			  On-update can be used to update individual properties of rows held in a table or named window.
        </para>

        <para>
			  The third means to handle updating events is the revision event types, for use with named windows only, as further described in <xref linkend="named_versioning"/>. With revision event types you can declare, via configuration only, multiple different event types. The engine can present a merged event type that contains a superset of properties of all merged types, and the engine can merge events as they arrive without additional EPL statements.
        </para>
	</sect1>

	<sect1 xml:id="eventrep-coarse">
	   <title>Coarse-Grained Events</title>
	   
		<indexterm><primary>event</primary><secondary>coarse</secondary></indexterm>
		<indexterm><primary>event</primary><secondary>bulk</secondary></indexterm>

        <para>
			Your application events may consist of fairly comprehensive, coarse-grained structures or documents. For example in business-to-business integration scenarios, XML documents or other event objects can be rich deeply-nested graphs of event properties.
        </para>

        <para>
			To extract information from a coarse-grained event or to perform bulk operations on the rows of the property graph in an event, Esper provides a convenient syntax: 
			When specifying a filter expression in a pattern or in a <literal>select</literal> clause, it may contain an contained-event selection syntax, as further described in <xref linkend="epl-containedeventselect"/>.
		</para>

	</sect1>

	<sect1 xml:id="eventrep-insertinto">
	   <title>Event Objects Instantiated and Populated by <literal>Insert Into</literal></title>
	   
		<indexterm><primary>event</primary><secondary>insert into</secondary></indexterm>

		<para>
			For NEsper .NET also see <xref linkend="appendix_dotnet_eventrep_insertinto"/>.
		</para>

        <para>
			The <literal>insert into</literal> clause can instantiate and populate new instances of Java object events, <literal>java.util.Map</literal> events and <literal>Object[]</literal> (object array) events directly from the results of <literal>select</literal> clause expressions. Simply use the event type name as the stream name in the <literal>insert into</literal> clause as described in <xref linkend="epl-insert-into"/>.
        </para>
        
        <para>
           If instead you have an existing instance of a Java object returned by an expression, such as a single-row function or static method invocation for example, you can transpose that expression result object to a stream. This is described further in <xref linkend="insert-into-expression"/> and <xref linkend="functionreference-transpose"/>.
        </para>

        <para>
			The column names specified in the <literal>select</literal> and <literal>insert into</literal> clause must match available writable properties in the event object to be populated (the target event type). The expression result types of any expressions in the <literal>select</literal> clause must also be compatible with the property types of the target event type.
		</para>

        <para>
			If populating a POJO-based event type and the class provides a matching constructor, the expression result types of expressions in the <literal>select</literal> clause must be compatible with the constructor parameters in the order listed by the constructor. The <literal>insert into</literal> clause column names are not relevant in this case.
		</para>

        <para>
			Consider the following example statement:
		</para>
		<programlisting>insert into com.mycompany.NewEmployeeEvent 
select fname as firstName, lname as lastName from HRSystemEvent</programlisting> 

        <para>
			The above example specifies the fully-qualified class name of <literal>NewEmployeeEvent</literal>. The engine instantianes <literal>NewEmployeeEvent</literal> for each result row and populates the <literal>firstName</literal> and <literal>lastName</literal> properties of each instance from the result of <literal>select</literal> clause expressions. The <literal>HRSystemEvent</literal> in the example is assumed to have <literal>lname</literal> and <literal>fname</literal> properties, and either setter-methods and a default constructor, or a matching constructor.
		</para>
		
        <para>
			Note how the example uses the <literal>as</literal>-keyword to assign column names that match the property names of the <literal>NewEmployeeEvent</literal> target event. If the property names of the source and target events are the same, the <literal>as</literal>-keyword is not required.
		</para>

        <para>
			The next example is an alternate form and specifies property names within the <literal>insert into</literal> clause instead. The example also assumes that <literal>NewEmployeeEvent</literal> has been defined or imported via configuration since it does not specify the event class package name:
		</para>
		<programlisting>insert into NewEmployeeEvent(firstName, lastName) 
select fname, lname from HRSystemEvent</programlisting> 

        <para>
			Finally, this example populates <literal>HRSystemEvent</literal> events. The example populates the value of a <literal>type</literal> property where the event has the value 'NEW' and populates a new event object with the value 'HIRED', copying the <literal>fname</literal> and <literal>lname</literal> property values to the new event object:
		</para>
		<programlisting>insert into HRSystemEvent 
select fname, lname, 'HIRED' as type from HRSystemEvent(type='NEW')</programlisting> 

        <para>
          The matching of the <literal>select</literal> or <literal>insert into</literal>-clause column names to target event type's property names is case-sensitive. You can specify a subset of all available columns in the target event type. Wildcard (<literal>*</literal>) is allowed and copies all fields of the events or multiple events in a join.
		</para>

        <para>
			For Java object events, your event class must provide setter-methods according to JavaBean conventions or, alternatively, a matching constructor. If the event class provides setter methods the class should also provide a default constructor taking no parameters. If the event class provides a matching constructor there is no need for setter-methods. If your event class does not have a default constructor and setter methods, or a matching constructor, your application may configure a factory method via <literal>ConfigurationEventTypeLegacy</literal>. If your event class does not have a default constructor and there is no factory method provided, the engine uses in connection with the Oracle JVM the <literal>sun.reflect.ReflectionFactory</literal>, noting that in this case member variables do not get initialized to assigned defaults.
		</para>

        <para>
			The engine follows Java standards in terms of widening, performing widening automatically in cases where widening type conversion is allowed without loss of precision, for both boxed and primitive types and including BigInteger and BigDecimal.
		</para>

        <para>
			When inserting array-typed properties into a Java, Map-type or Object-array underlying event the event definition should declare the target property as an array.
		</para>

        <para>
		    Please note the following limitations: 
		</para>
		<itemizedlist spacing="compact">
			<listitem>
				<para>
					Event types that utilize XML <literal>org.w3c.dom.Node</literal> underlying event objects cannot be target of an <literal>insert into</literal> clause.
				</para>
			</listitem>
		</itemizedlist>
	</sect1>

</chapter>
