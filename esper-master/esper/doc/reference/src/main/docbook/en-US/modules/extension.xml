<chapter xml:id="extension" version="5.0"
         xsi:schemaLocation="http://docbook.org/ns/docbook http://www.docbook.org/xml/5.0/xsd/docbook.xsd http://www.w3.org/1999/xlink http://www.docbook.org/xml/5.0/xsd/xlink.xsd"
         xml:base="./" xmlns="http://docbook.org/ns/docbook" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:ns="http://docbook.org/ns/docbook">

    <title>Integration and Extension</title>
    
    <sect1 xml:id="extension-overview" revision="1">
        <title>Overview</title>

		<para>
		  This chapter summarizes integration and describes in detail each of the extension APIs that allow integrating external data and/or extend engine functionality. 
		</para>

		<para>
		  For information on calling external services via instance method invocation, for instance to integrate with dependency injection frameworks such as Spring or Guice,
		  please see <xref linkend="variable_eventtype"/>.
		</para>
		  
		<para>
		  For information on input and output adapters that connect to an event transport and perform event transformation for incoming and outgoing on-the-wire event data, for use with streaming data, please see the EsperIO reference documentation. The data flow instances as described in <xref linkend="dataflow"/> are an easy way to plug in operators that perform input and output. 
		  Data flows allow providing parameters and managing individual flows independent of engine lifecycle.
		  Also consider using the Plug-in Loader API for creating a new adapter that starts or stops as part of the CEP engine initialization and destroy lifecycle, see <xref linkend="api-plugin"/>.
		</para>
		
		<para>
		  To join data that resides in a relational database and that is accessible via JDBC driver and SQL statement the engine offers a syntax for using SQL within EPL, see <xref linkend="histdata_overview"/>. A relational database input and output adapter for streaming input from and output to a relational database also exists (EsperIO).
		</para>
		
		<para>
		  To join data that resides in a non-relational store the engine offers a two means: First, the virtual data window, as described below, for transparently integrating the external store as a named window. The second mechanism is a special join syntax based on static method invocation, see <xref linkend="joining_method"/>.
		</para>
		
		<tip><title>Tip</title>
		  <para>
		  The best way to test that your extension code works correctly is to write unit tests against an EPL statement that utilizes the extension code. Samples can be obtained from Esper regression test code base.
		  </para>
	   </tip>
		
		<note>
			<para>
			  For all extension code and similar to listeners and subscribers, to send events into the engine from extension code the <literal>route</literal> method should be used (and not <literal>sendEvent</literal>) to avoid the possibility of stack overflow due to event-callback looping and ensure correct processing of the current and routed event.
			  Note that if outbound-threading is enabled, listeners and subscribers should use <literal>sendEvent</literal> and not <literal>route</literal>.
			</para>
		</note>
		
		<note>
			<para>
			  For all extension code it is not safe to administrate the engine within the extension code. For example, it is not safe to implement a data window that creates a new statement or destroys an existing statement.
			</para>
		</note>
    </sect1>
    
    <sect1 xml:id="extension-virtualdw" revision="1">
        <title>Virtual Data Window</title>
        
        <para>
			Use a virtual data window if you have a (large) external data store that you want to access as a named window. The access is transparent: There is no need to use special syntax or join syntax. All regular queries including subqueries, joins, on-merge, on-select, on-insert, on-delete, on-update and fire-and-forget are supported with virtual data windows.
        </para>
        
        <para>
           There is no need to keep any data or events in memory with virtual data windows. The only requirement for virtual data windows is that all data rows returned are <literal>EventBean</literal> instances.
        </para>

        <para>
			When implementing a virtual data window it is not necessary to send any events into the engine or to use insert-into. The event content is simply assumed to exist and accessible to the engine via the API implementation you provide. 
        </para>
        
        <para>
          The distribution ships with a sample virtual data window in the examples folder under the name <literal>virtualdw</literal>. The code snippets below are extracts from the example.
        </para>
        
        <para>
			We use the term <emphasis>store</emphasis> here to mean a source set of data that is managed by the virtual data window. We use the term <emphasis>store row</emphasis> or just <emphasis>row</emphasis> to mean a single data item provided by the store. We use the term <emphasis>lookup</emphasis>
			to mean a read operation against the store returning zero, one or many rows.
        </para>
        
        <para>
           Virtual data windows allow high-performance low-latency lookup by exposing all relevant EPL query access path information. This makes it possible for the virtual data window to choose the desired access method into its store.
        </para>
        
        <para>
			The following steps are required to develop and use a virtual data window: 
        </para>
			
		<orderedlist spacing="compact">
			<listitem>
				<para>
					Implement the interface <literal>com.espertech.esper.client.hook.VirtualDataWindowFactory</literal>.
				</para>
			</listitem>
			<listitem>
				<para>
					Implement the interface <literal>com.espertech.esper.client.hook.VirtualDataWindow</literal>.
				</para>
			</listitem>
			<listitem>
				<para>
					Implement the interface <literal>com.espertech.esper.client.hook.VirtualDataWindowLookup</literal>.
				</para>
			</listitem>
			<listitem>
				<para>
					Register the factory class in the engine configuration.
				</para>
			</listitem>
		</orderedlist>
		
		<para> 
			Once you have completed above steps, the virtual data window is ready to use in EPL statements.
		</para>       	
				
		<para>
		  From a threading perspective, virtual data window implementation classes must be thread-safe if objects are shared between multiple named windows. If no objects are shared between multiple different named windows, thereby each object is only used for the same named window and other named windows receive a separate instance, it is no necessary that the implementation classes are thread-safe.
		</para>

		<sect2 xml:id="extension-virtualdw-howto" revision="1">
			<title>How to Use</title>
			
			<para>
				Your application must first register the virtual data window factory as part of engine configuration:
			</para>
			
			<programlisting><![CDATA[Configuration config = new Configuration();
config.addPlugInVirtualDataWindow("sample", "samplevdw", 
    SampleVirtualDataWindowFactory.class.getName());]]></programlisting>

			<para>
				Your application may then create a named window backed by a virtual data window.
			</para>

			<para>
				For example, assume that the <literal>SampleEvent</literal> event type is declared as follows:
			</para>				
			<programlisting><![CDATA[create schema SampleEvent as (key1 string, key2 string, value1 int, value2 double)]]></programlisting>

			<para>
				The next EPL statement creates a named window <literal>MySampleWindow</literal> that provides <literal>SampleEvent</literal> events and is backed by a virtual data window provided by <literal>SampleVirtualDataWindowFactory</literal> as configured above:
			</para>
			<programlisting><![CDATA[create window MySampleWindow.sample:samplevdw() as SampleEvent]]></programlisting>
			
			<para>
			    You may then access the named window, same as any other named window, for example by subquery, join, on-action, fire-and-forget query or by consuming its insert and remove stream. While this example uses Map-type events, the example code is the same for POJO or other events.
			</para>
			
			<para>
				Your application may obtain a reference to the virtual data window from the engine context.
			</para>
	
			<para>
			  This code snippet looks up the virtual data window by the named window name:
			</para>
			<programlisting><![CDATA[try {
  return (VirtualDataWindow) epService.getContext().lookup("/virtualdw/MySampleWindow");
}
catch (NamingException e) {
  throw new RuntimeException("Failed to look up virtual data window, is it created yet?");
}]]></programlisting>

			<sect3 xml:id="extension-virtualdw-howto-access" revision="1">
				<title>Query Access Path</title>
				
				<para>
					When you application registers a subquery, join or on-action query or executes a fire-and-forget query against a virtual data window the engine interacts with the virtual data window. The interaction is a two-step process. 
				</para>
				
				<para>
					At time of EPL statement creation (once), the engine analyzes the EPL where-clause, if present. It then compiles a list of hash-index and binary tree (btree, i.e. sorted) index properties. It passes the property names that are queried as well as the operators (i.e. =, &gt;, range etc.) to the virtual data window. The virtual data window returns a lookup strategy object to the engine.
				</para>
				
				<para>
					At time of EPL statement execution (repeatedly as triggered) , the engine uses that lookup strategy object to execute a lookup. It passes to the lookup all actual key values (hash, btree including ranges) to make fast and efficient lookup achievable.
				</para>
				
				<para>
				    To explain in detail, assume that your application creates an EPL statement with a subquery as follows:
				</para>
				<programlisting><![CDATA[select (select * from MySampleWindow where key1 = 'A1') from OtherEvent]]></programlisting>
				
				<para>
				  At the time of creation of the EPL query above the engine analyzes the EPL query. It determines that the subquery queries a virtual data window.  It determines from the where-clause that the lookup uses property <literal>key1</literal> and hash-equals semantics. The engine then provides this information as part of <literal>VirtualDataWindowLookupContext</literal> passed to the <literal>getLookup</literal> method. Your application may inspect hash and btree properties and may determine the appropriate store access method to use.
				</para>
				
				<para>
					The hash and btree property lookup information is for informational purposes, to enable fast and performant queries that returns the smallest number of rows possible. Your implementation classes may use some or none of the information provided and may also instead return some or perhaps even all rows, as is practical to your implementation. The <literal>where</literal>-clause still remains in effect and gets evaluated on all rows that are returned by the lookup strategy.
				</para>

				<para>
				  Following the above example, the sub-query executes once when a <literal>OtherEvent</literal> event arrives. At time of execution the engine delivers the string value <literal>A1</literal> to the <literal>VirtualDataWindowLookup</literal> lookup implementation provided by your application. The lookup object queries the store and returns 
				  store rows as <literal>EventBean</literal> instances.
				</para>

				<para>
				    As a second example, consider an EPL join statement as follows:
				</para>
				<programlisting><![CDATA[select * from MySampleWindow, MyTriggerEvent where key1 = trigger1 and key2 = trigger2]]></programlisting>
				
				<para>
					The engine analyzes the query and passes to the virtual data window the information that the lookup occurs on properties <literal>key1</literal> and <literal>key2</literal> under hash-equals semantics. When a <literal>MyTriggerEvent</literal> arrives, 
					it passes the actual value of the <literal>trigger1</literal> and <literal>trigger2</literal> properties of the current MyTriggerEvent to the lookup.
				</para>
				
				<para>
				    As a last example, consider an EPL fire-and-forget statement as follows:
				</para>
				<programlisting><![CDATA[select * from MySampleWindow key1 = 'A2' and value1 between 0 and 1000]]></programlisting>
				
				<para>
					The engine analyzes the query and passes to the virtual data window the lookup information.  The lookup occurs on property <literal>key1</literal> under hash-equals semantics and on property <literal>value1</literal> under btree-open-range semantics. When you application 
					executes the fire-and-forget query the engine passes <literal>A2</literal> and the range endpoints <literal>0</literal> and <literal>1000</literal> to the lookup.
				</para>
				
				<para>
					For more information, please consult the JavaDoc API documentation for class <literal>com.espertech.esper.client.hook.VirtualDataWindow</literal>, <literal>VirtualDataWindowLookupContext</literal> or <literal>VirtualDataWindowLookupFieldDesc</literal>.
				</para>
			</sect3>
		</sect2>

		<sect2 xml:id="extension-virtualdw-vdwfactory" revision="1">
			<title>Implementing the Factory</title>
			
			<para>
			  For each named window that refers to the virtual data window, the engine instantiates one instance of the factory.
			</para>
			
			<para>
				A virtual data window factory class is responsible for the following functions:
			</para>
			<itemizedlist spacing="compact">
				<listitem>
					<para>
						Implement the <literal>initialize</literal> method that accepts a virtual data window factory context object as a parameter.
					</para>
				</listitem>
				<listitem>
					<para>
						Implement the <literal>create</literal> method that accepts a virtual data window context object as a parameter and returns a <literal>VirtualDataWindow</literal> implementation.
					</para>
				</listitem>
				<listitem>
					<para>
						Implement the <literal>destroyAllContextPartitions</literal> method that gets called once when the named window is stopped or destroyed.
					</para>
				</listitem>
			</itemizedlist>
			
			<para>
			  The engine instantiates a <literal>VirtualDataWindowFactory</literal> instance for each named window created via <literal>create window</literal>. The engine invokes the <literal>initialize</literal> method once in respect to the named window being created passing a <literal>VirtualDataWindowFactoryContext</literal> context object.
			</para>

			<para>
			  If not using contexts, the engine calls the <literal>create</literal> method once after calling the <literal>initialize</literal> method. If using contexts, the engine calls the <literal>create</literal> method every time it allocates a context partition.
			  If using contexts and your virtual data window implementation operates thread-safe, you may return the same virtual data window implementation object for each context partition. If using contexts and your implementation object is not thread safe, return a separate thread-safe implementation object for each context partition.
			</para>

			<para>
			  The engine invokes the <literal>destroyAllContextPartitions</literal> once when the named window is stopped or destroyed. If not using contexts, the engine calls the <literal>destroy</literal> method of the virtual data window implementation object before calling
			  the <literal>destroyAllContextPartitions</literal> method on the factory object. If using contexts, the engine calls the <literal>destroy</literal> method on each instance associates to a context partition at the time when the associated context partition terminates.
			</para>

			<para>
				The sample code shown here can be found among the examples in the distribution under <literal>virtualdw</literal>:
			</para>
			<programlisting><![CDATA[public class SampleVirtualDataWindowFactory implements VirtualDataWindowFactory {

    public void initialize(VirtualDataWindowFactoryContext factoryContext) {
		// Can add initialization logic here.
    }

  public VirtualDataWindow create(VirtualDataWindowContext context) {
    // This example allocates a new virtual data window (one per context partitions if using contexts).
    // For sharing the virtual data window instance between context partitions, return the same reference.
    return new SampleVirtualDataWindow(context);
  }
  
  public void destroyAllContextPartitions() {
    // Release shared resources here
  }
}]]></programlisting>

			<para>
				Your factory class must implement the <literal>create</literal> method which receives a <literal>VirtualDataWindowContext</literal> object. This method is called once for each EPL that creates a virtual data window (see example <literal>create window</literal> above).
			</para>
    
			<para>
				The <literal>VirtualDataWindowContext</literal> provides to your application:
			</para>
			<programlisting><![CDATA[String namedWindowName;	// Name of named window being created.
Object[] parameters;  // Any optional parameters provided as part of create-window.
EventType eventType;  // The event type of events.
EventBeanFactory eventFactory;  // A factory for creating EventBean instances from store rows.
VirtualDataWindowOutStream outputStream;  // For stream output to consuming statements.
AgentInstanceContext agentInstanceContext;  // Other EPL statement information in statement context.]]></programlisting>

			<para>
			    When using contexts you can decide whether your factory returns a new virtual data window for each context partition or returns the same virtual data window instance for all context partitions.
			    Your extension code may refer to the named window name to identify the named window and may refer to the agent instance context that holds the agent instance id which is the id of the context partition. 
			</para>
		</sect2>

		<sect2 xml:id="extension-virtualdw-vdw" revision="1">
			<title>Implementing the Virtual Data Window</title>
			
			<para>
				A virtual data window implementation is responsible for the following functions:
			</para>
			<itemizedlist spacing="compact">
				<listitem>
					<para>
						Accept the lookup context object as a parameter and return the <literal>VirtualDataWindowLookup</literal> implementation.
					</para>
				</listitem>
				<listitem>
					<para>
						Optionally, post insert and remove stream data.
					</para>
				</listitem>
				<listitem>
					<para>
						Implement the <literal>destroy</literal> method, which the engine calls for each context partition when the named window is stopped or destroyed, or once when a context partition is ended/terminated.
					</para>
				</listitem>
			</itemizedlist>

			<para>
				The sample code shown here can be found among the examples in the distribution under <literal>virtualdw</literal>.
			</para>

			<para>
			  The implementation class must implement the <literal>VirtualDataWindow</literal> interface like so:
			</para>
			<programlisting><![CDATA[public class SampleVirtualDataWindow implements VirtualDataWindow {

  private final VirtualDataWindowContext context;
  
  public SampleVirtualDataWindow(VirtualDataWindowContext context) {
    this.context = context;
  } ...]]></programlisting>

			<para>
			  When the engine compiles an EPL statement and detects a virtual data window, the engine invokes the <literal>getLookup</literal> method indicating hash and btree access path information by passing a <literal>VirtualDataWindowLookupContext</literal> context. The lookup method must return a <literal>VirtualDataWindowLookup</literal> implementation that the EPL statement
			  uses for all lookups until the EPL statement is stopped or destroyed.
			</para>
			
			<para>
			  The sample implementation does not use the hash and btree access path information and simply returns a lookup object: 
			</para>
			<programlisting><![CDATA[public VirtualDataWindowLookup getLookup(VirtualDataWindowLookupContext desc) {

  // Place any code that interrogates the hash-index and btree-index fields here.

  // Return the lookup strategy.
  return new SampleVirtualDataWindowLookup(context);
}]]></programlisting>

			<para>
				If your virtual data window returns null instead of a lookup object, the EPL query creation fails and throws an <literal>EPStatementException</literal>.
			</para>

			<para>
			 The engine calls the <literal>update</literal> method when data changes because of on-merge, on-delete, on-update or insert-into. For example, if you have an on-merge statement that is triggered and that updates the virtual data window, the <literal>newData</literal> parameter receives the new (updated) event and the <literal>oldData</literal> parameters receives the event prior to the update. Your code may use these events to update the store or delete from the store, if needed.
			</para>

			<para>
				If your application plans to consume data from the virtual data window, for example via <literal>select * from MySampleWindow</literal>, then the code must implement the <literal>update</literal> method to forward insert and remove stream events, as shown below, to receive the events in consuming statements. To post insert and remove stream data, use the <literal>VirtualDataWindowOutStream</literal> provided by the context object as follows. 
			</para>
			
			<programlisting><![CDATA[public void update(EventBean[] newData, EventBean[] oldData) {
  // This sample simply posts into the insert and remove stream what is received.
  context.getOutputStream().update(newData, oldData);
}]]></programlisting>

			<para>
				Your application should not use <literal>VirtualDataWindowOutStream</literal> to post new events that originate from the store. The object is intended for use with on-action EPL statements. Use insert-into instead for any new events that originate from the store.
			</para>
		</sect2>

		<sect2 xml:id="extension-virtualdw-lookup" revision="1">
			<title>Implementing the Lookup</title>
			
			<para>
				A lookup implementation is responsible for the following functions:
			</para>
			<itemizedlist spacing="compact">
				<listitem>
					<para>
						Accept the lookup values as a parameter and return a set of <literal>EventBean</literal> instances.
					</para>
				</listitem>
			</itemizedlist>

			<para>
				The sample code shown here can be found among the examples in the distribution under <literal>virtualdw</literal>.
			</para>

			<para>
			  The implementation class must implement the <literal>VirtualDataWindowLookup</literal> interface:
			</para>
			<programlisting><![CDATA[public class SampleVirtualDataWindowLookup implements VirtualDataWindowLookup {

  private final VirtualDataWindowContext context;
  
  public SampleVirtualDataWindowLookup(VirtualDataWindowContext context) {
    this.context = context;
  } ...]]></programlisting>

			<para>
			  When an EPL query fires, the engine invokes the lookup and provides the actual lookup values. The lookup values are provided in the same exact order as the access path information that the engine provided when obtaining the lookup.
			</para>
			
			<para>
				Each store row must be wrapped as an <literal>EventBean</literal> instance. The context object provides an <literal>EventBeanFactory</literal> implementation returned by <literal>getEventFactory()</literal> that can be used to wrap rows.
			</para>
			
			<para>
			  The sample implementation does not use the lookup values and simply returns a hardcoded sample event: 
			</para>
			<programlisting><![CDATA[public Set<EventBean> lookup(Object[] lookupValues) {
  // Add code to interogate lookup values here.

  // Create sample event.
  // This example uses Map events; Other underlying events such as POJO are exactly the same code.
  Map<String, Object> eventData = new HashMap<String, Object>();
  eventData.put("key1", "sample1");
  eventData.put("key2", "sample2");
  eventData.put("value1", 100);
  eventData.put("value2", 1.5d);
  EventBean event = context.getEventFactory().wrap(eventData);
  return Collections.singleton(event);
}]]></programlisting>

			<para>
				The <literal>lookupValues</literal> object array represents all actual joined property values or expression results if you where-clause criteria are expressions. The code may use these keys to for efficient store access.
			</para>
			
			<para>
				When a key value is a range, the key value is an instance of <literal>VirtualDataWindowKeyRange</literal>.
			</para>
		</sect2>

    </sect1>

    <sect1 xml:id="custom-singlerow-function" revision="1">
        <title>Single-Row Function</title>
        
		<indexterm><primary>plug-in</primary><secondary>single-row function</secondary></indexterm>
		<indexterm><primary>single-row functions</primary><secondary>custom plug-in</secondary></indexterm>
        <para>
			Single-row functions return a single value. They are not expected to aggregate rows but instead should be stateless functions. These functions can appear in any expressions and can be passed any number of parameters.
        </para>

        <para>
			The following steps are required to develop and use a custom single-row function with Esper. 
        </para>
			
		<orderedlist spacing="compact">
			<listitem>
				<para>
					Implement a class providing one or more public static methods accepting the number and type of parameters as required.
				</para>
			</listitem>
			<listitem>
				<para>
					Register the single-row function class and method name with the engine by supplying a function name, via the engine configuration file or the configuration API.
				</para>
			</listitem>
		</orderedlist>
		
		<para>
			You may not override a built-in function with a single-row function provided by you. The single-row function you register must have a different name then any of the built-in functions.
		</para>
		
		<para>
			An example single-row function can also be found in the examples under the runtime configuration example.
		</para>

		<sect2 xml:id="custom-singlerow-implementing" revision="1">
			<title>Implementing a Single-Row Function</title>
			
			<para>
				Single-row function classes have no further requirement then provide a public static method.
			</para>

			<para>
				The following sample single-row function simply computes a percentage value based on two number values. 
			</para>

			<para>
				This sample class provides a public static method by name <literal>computePercent</literal> to return a percentage value:
			</para>
			<programlisting><![CDATA[public class MyUtilityClass {
  public static double computePercent(double amount, double total) {
    return amount / total * 100;
  }
}]]></programlisting>
		</sect2>

		<sect2 xml:id="custom-single-row-config" revision="1">
			<title>Configuring the Single-Row Function Name</title>
			
			<para>
				The class name of the class, the method name and the function name of the new single-row function must be added to the engine configuration via the configuration API or using the XML configuration file. The configuration shown below is XML however the same options are available through the runtime and static configuration API:
			</para>
		
			<programlisting><![CDATA[<esper-configuration
  <plugin-singlerow-function name="percent" 
    function-class="mycompany.MyUtilityClass" function-method="computePercent" />
</esper-configuration>]]></programlisting>

			<para>
				Note that the function name and method name need not be the same.
			</para>

			<para>
				The new single-row function is now ready to use in a statement:
			</para>		
			<programlisting><![CDATA[select percent(fulfilled,total) from MyEvent]]></programlisting>

			<para>
				When selecting from a single stream, you may also pass wildcard to the single-row function and the function receives the underlying event:
			</para>		
			<programlisting><![CDATA[select percent(*) from MyEvent]]></programlisting>

			<para>
				If the single-row function returns an object that provides further functions, you may chain function calls.
			</para>
			
			<para>
				The following demonstrates a chained single-row function. The example assumes that a single-row function by name <literal>calculator</literal> returns an object that provides the <literal>add</literal> function which accepts two parameters:
			</para>
			<programlisting><![CDATA[select calculator().add(5, amount) from MyEvent]]></programlisting>
		</sect2>

		<sect2 xml:id="custom-single-row-cache" revision="1">
			<title>Value Cache</title>
			
			<para>
				When a single-row function receives parameters that are all constant values or expressions that themselves receive only constant values, Esper can pre-evaluate the result of the single-row function at time of statement creation. By default, Esper does not pre-evaluate the single-row function unless you configure
				the value cache as enabled.
			</para>
			
			<para>
			  The following configuration XML enables the value cache for the single-row function:
			</para>
			<programlisting><![CDATA[<esper-configuration
  <plugin-singlerow-function name="getDate" 
    function-class="mycompany.DateUtil" function-method="parseDate"
    value-cache="enabled" />
</esper-configuration>]]></programlisting>

			<para>
				When the single-row function receives constants as parameters, the engine computes the result once and returns the cached result for each evaluation:
			</para>		
			<programlisting><![CDATA[select getDate('2002-05-30T9:00:00.000') from MyEvent]]></programlisting>
		</sect2>

		<sect2 xml:id="custom-single-filter-optimizable" revision="1">
			<title>Single-Row Functions in Filter Predicate Expressions</title>

			<para>
			  Your EPL may use plug-in single row functions among the predicate expressions as part of the filters in a stream or pattern.
			</para>
			
			<para>
			  For example, the EPL below uses the function <literal>computeHash</literal> as part of a predicate expression:
			</para>
			<programlisting><![CDATA[select * from MyEvent(computeHash(field) = 100)]]></programlisting>

			<para>
			   When you have many EPL statements or many context partitions that refer to the same function, event type and parameters in a predicate expression, the engine may optimize evaluation: The function gets evaluated only once per event.
			</para>
			
			<para>
				While the optimization is enabled by default for all plug-in single row functions, you can also disable the optimization for a specific single-row function. By disabling the optimization for a single-row function the engine may use less memory to identify reusable function footprints but may cause the engine to evaluate each function more frequently then necessary.
			</para>
			
			<para>
			  The following configuration XML disables the filter optimization for a single-row function (by default it is enabled):
			</para>
			<programlisting><![CDATA[<esper-configuration
  <plugin-singlerow-function name="computeHash" 
    function-class="mycompany.HashUtil" function-method="computeHash"
    filter-optimizable="disabled" />
</esper-configuration>]]></programlisting>
		</sect2>

		<sect2 xml:id="custom-single-eventsparam" revision="1">
			<title>Single-Row Functions Taking Events as Parameters</title>

			<para>
			  Esper allows parameters to a single-row function to be events. In this case, declare the method parameter type to either take <literal>EventBean</literal>, <literal>Collection&lt;EventBean&gt;</literal>
			  or the underlying class as a parameter.			  
			</para>
			
			<para>
			  Sample method footprints are:
			</para>
			<programlisting><![CDATA[public static double doCompute(EventBean eventBean) {...}
public static boolean doCheck(MyEvent myEvent, String text) {...}
public static String doSearch(Collection<EventBean> events) {...}]]></programlisting>

			<para>
			  To pass the event, specify the stream alias, or wildcard <literal>(*)</literal> or the tag name when used in a pattern.
			</para>
			
			<para>
			  The EPL below shows example uses:
			</para>
			<programlisting><![CDATA[select * from MyEvent(doCompute(me) = 100) as me]]></programlisting>
			<programlisting><![CDATA[select * from MyEvent where doCompute(*) = 100]]></programlisting>
			<programlisting><![CDATA[select * from pattern[a=MyEvent -> MyEvent(doCheck(a, 'sometext'))]]]></programlisting>
			<programlisting><![CDATA[select * from MyEvent#time(1 min) having doCompute(last(*))]]]></programlisting>
			<programlisting><![CDATA[select * from MyEvent#time(1 min) having doSearch(window(*))]]]></programlisting>
			
			<para>
			  Declare the method parameter as <literal>Collection&lt;EventBean&gt;</literal> if the method expects 
			  an expression result that returns multiple events.
			</para>

			<para>
			  Declare the method parameter as <literal>EventBean</literal> if the method expects 
			  an expression result that returns a single event.
			</para>
		</sect2>

		<sect2 xml:id="custom-single-returningevents" revision="1">
			<title>Single-Row Functions Returning Events</title>

			<para>
			  A single-row function may return events. Please declare your single-row function method to return <literal>Collection&lt;EventBean&gt;</literal> or <literal>EventBean[]</literal> and configure the event type name.
			</para>
			
			<para>
			  For example, assuming there is an <literal>MyItem</literal> event type such as created via <literal>create schema MyItem(id string)</literal>:
			</para>
			<programlisting><![CDATA[public static EventBean[] myItemProducer(String string, EPLMethodInvocationContext context) {
  String[] split = string.split(",");
  EventBean[] events = new EventBean[split.length];
  for (int i = 0; i < split.length; i++) {
    events[i] = context.getEventBeanService().adapterForMap(Collections.singletonMap("id", split[i]), "MyItem");
  }
  return events;
}]]></programlisting>

			<para>
			  The sample EPL queries items filtering those items that have a given value for the <literal>id</literal> field:
			</para>
			<programlisting><![CDATA[select myItemProducer(ordertext).where(v => v.id in ('id1', 'id3')) as c0 from Order]]></programlisting>			

			<para>
			  This sample code register the <literal>myItemProducer</literal> function as a single-row function with an event type name:
			</para>
			<programlisting><![CDATA[ConfigurationPlugInSingleRowFunction entry = new ConfigurationPlugInSingleRowFunction();
entry.setName("myItemProducer");
entry.setFunctionClassName(...);
entry.setFunctionMethodName(...);
entry.setEventTypeName("MyItem");
epService.getEPAdministrator().getConfiguration().addPlugInSingleRowFunction(entry);]]></programlisting>			
			
			<para>
				If your single row function returns <literal>EventBean[]</literal> and is used with enumeration methods the configuration must provide an event type name.
			</para>
		</sect2>

		<sect2 xml:id="custom-single-receivectx" revision="1">
			<title>Receiving a Context Object</title>

			<para>
			  Esper can pass an object containing contextual information such as statement name, function name, engine URI and context partition id to your
			  method. The container for this information is <literal>EPLMethodInvocationContext</literal> in package <literal>com.espertech.esper.client.hook</literal>.
			  Please declare your method to take <literal>EPLMethodInvocationContext</literal> as the last parameter. The engine then passes the information along.
			</para>
			
			<para> 
			  A sample method footprint and EPL are shown below:
			</para>					
			<programlisting><![CDATA[public static double computeSomething(double number, EPLMethodInvocationContext context) {...}]]></programlisting>
			<programlisting><![CDATA[select computeSomething(10) from MyEvent]]></programlisting>
		</sect2>

		<sect2 xml:id="custom-single-rethrowex" revision="1">
			<title>Exception Handling</title>

			<para>
			  By default the engine logs any exceptions thrown by the single row function and returns a null value. 
			  To have exceptions be re-thrown instead, which makes exceptions visible to any registered exception handler,
			  please configure as discussed herein. 
			</para>
						
			<para>
				Set the <literal>rethrow-exceptions</literal> flag in the XML configuration or the <literal>rethrowExceptions</literal> flag in the API
				when registering the single row function to have the engine re-throw any exceptions that the single row function may throw.
			</para>
		</sect2>
	</sect1>

    <sect1 xml:id="custom-views" revision="1">
        <title>Derived-Value and Data Window View</title>
        
		<indexterm><primary>plug-in</primary><secondary>custom view</secondary></indexterm>
		<indexterm><primary>data window</primary><secondary>custom plug-in view</secondary></indexterm>
        <para>
			Views in Esper are used to derive information from an event stream, and to represent data windows onto an event stream. This chapter describes how to plug-in a new, custom view. 
        </para>
        
        <para>
			The following steps are required to develop and use a custom view with Esper. 
        </para>
			
		<orderedlist spacing="compact">
			<listitem>
				<para>
					Implement a view factory class. View factories are classes that accept and check view parameters and instantiate the appropriate view class.
				</para>
			</listitem>
			<listitem>
				<para>
					Implement a view class. A view class commonly represents a data window or derives new information from a stream.
				</para>
			</listitem>
			<listitem>
				<para>
					Configure the view factory class supplying a view namespace and name in the engine configuration file.
				</para>
			</listitem>
		</orderedlist>

        <para>
			The example view factory and view class that are used in this chapter can be found in the examples source folder in the OHLC (open-high-low-close) example. The class names are <literal>OHLCBarPlugInViewFactory</literal> and <literal>OHLCBarPlugInView</literal>.
        </para>

        <para>
			Views can make use of the following engine services available via <literal>StatementServiceContext</literal>:
        </para>
        
		<itemizedlist spacing="compact">
			<listitem>
				<para>
					The <literal>SchedulingService</literal> interface allows views to schedule timer callbacks to a view
				</para>
			</listitem>
			<listitem>
				<para>
					The <literal>EventAdapterService</literal> interface allows views to create new event types and event instances of a given type. 
				</para>
			</listitem>
			<listitem>
				<para>
					The <literal>StatementStopService</literal> interface allows view to register a callback that the engine invokes to indicate that the view's statement has been stopped
				</para>
			</listitem>
		</itemizedlist>

        <para>
			<xref linkend="custom-views-contract"/> outlines the requirements for correct behavior of a your custom view within the engine.
        </para>

        <para>
			Note that custom views may use engine services and APIs that can be subject to change between major releases. The engine services discussed above and view APIs are considered part of the engine internal public API and are stable. Any changes to such APIs are disclosed through the release change logs and history. Please also consider contributing your custom view to the Esper project team by submitting the view code through the mailing list or via a JIRA issue.
        </para>

		<sect2 xml:id="custom-views-viewfactory" revision="1">
			<title>Implementing a View Factory</title>
			
			<para>
				A view factory class is responsible for the following functions:
			</para>
			<itemizedlist spacing="compact">
				<listitem>
					<para>
						Accept zero, one or more view parameters. View parameters are themselves expressions. The view factory must validate and evaluate these expressions.
					</para>
				</listitem>
				<listitem>
					<para>
						Instantiate the actual view class.
					</para>
				</listitem>
				<listitem>
					<para>
						Provide information about the event type of events posted by the view.
					</para>
				</listitem>
			</itemizedlist>

			<para>
				View factory classes simply subclass <literal>com.espertech.esper.view.ViewFactorySupport</literal>:
			</para>
			<programlisting><![CDATA[public class OHLCBarPlugInViewFactory extends ViewFactorySupport { ...]]></programlisting>

			<para>
				Your view factory class must implement the <literal>setViewParameters</literal> method to accept and parse view parameters. The next code snippet shows an implementation of this method. The code checks the number of parameters and retains the parameters passed to the method:
			</para>
			<programlisting><![CDATA[public class OHLCBarPlugInViewFactory extends ViewFactorySupport {
    private ViewFactoryContext viewFactoryContext;
    private List<ExprNode> viewParameters;
    private ExprNode timestampExpression;
    private ExprNode valueExpression;

    public void setViewParameters(ViewFactoryContext viewFactoryContext, 
            List<ExprNode> viewParameters) throws ViewParameterException {
        this.viewFactoryContext = viewFactoryContext;
        if (viewParameters.size() != 2) {
            throw new ViewParameterException(
                "View requires a two parameters: " +
                "the expression returning timestamps and the expression supplying OHLC data points");
        }
        this.viewParameters = viewParameters;
    }
  ...]]></programlisting>
    
		<para>
			After the engine supplied view parameters to the factory, the engine will ask the view to attach to its parent view and validate any parameter expressions against the parent view's event type. If the view will be generating events of a different type then the events generated by the parent view, then the view factory can create the new event type in this method:
		</para>

		<programlisting><![CDATA[public void attach(EventType parentEventType, 
		StatementContext statementContext, 
		ViewFactory optionalParentFactory, 
		List<ViewFactory> parentViewFactories) throws ViewParameterException {
		
    ExprNode[] validatedNodes = ViewFactorySupport.validate("OHLC view", 
	      parentEventType, statementContext, viewParameters, false);

    timestampExpression = validatedNodes[0];
    valueExpression = validatedNodes[1];

    if ((timestampExpression.getExprEvaluator().getType() != long.class) && 
        (timestampExpression.getExprEvaluator().getType() != Long.class)) {
        throw new ViewParameterException(
            "View requires long-typed timestamp values in parameter 1");
    }
    if ((valueExpression.getExprEvaluator().getType() != double.class) && 
        (valueExpression.getExprEvaluator().getType() != Double.class)) {
        throw new ViewParameterException(
            "View requires double-typed values for in parameter 2");
    }
}]]></programlisting>

		<para>
			Finally, the engine asks the view factory to create a view instance, and asks for the type of event generated by the view:
		</para>

		<programlisting><![CDATA[public View makeView(AgentInstanceViewFactoryChainContext agentInstanceViewFactoryContext) {
    return new OHLCBarPlugInView(agentInstanceViewFactoryContext, timestampExpression, valueExpression);
}

public EventType getEventType() {
    return OHLCBarPlugInView.getEventType(viewFactoryContext.getEventAdapterService());
}]]></programlisting>
		</sect2>
		
		<sect2 xml:id="custom-views-view" revision="1">
			<title>Implementing a View</title>
			
			<para>
				A view class is responsible for:
			</para>
			<itemizedlist spacing="compact">
				<listitem>
					<para>
						The <literal>setParent</literal> method informs the view of the parent view's event type
					</para>
				</listitem>
				<listitem>
					<para>
						The <literal>update</literal> method receives insert streams and remove stream events from its parent view
					</para>
				</listitem>
				<listitem>
					<para>
						The <literal>iterator</literal> method supplies an (optional) iterator to allow an application to pull or request results from an <literal>EPStatement</literal>
					</para>
				</listitem>
			</itemizedlist>

			<para>
				View classes simply subclass <literal>com.espertech.esper.view.ViewSupport</literal>:
			</para>
			<programlisting><![CDATA[public class MyTrendSpotterView extends ViewSupport { ...]]></programlisting>

			<para>
				Your view's <literal>update</literal> method will be processing incoming (insert stream) and outgoing (remove stream) events posted by the parent view (if any), as well as providing incoming and outgoing events to child views. The convention required of your update method implementation is that the view releases any insert stream events (EventBean object references) which the view generates as reference-equal remove stream events (EventBean object references) at a later time. 
			</para>

			<para>
				The view implementation must call the <literal>updateChildren</literal> method to post outgoing insert and remove stream events. Similar to the <literal>update</literal> method, the <literal>updateChildren</literal> method takes insert and remove stream events as parameters.
			</para>

			<para>
				A sample <literal>update</literal> method implementation is provided in the OHLC example.
			</para>
		</sect2>

		<sect2 xml:id="custom-views-contract" revision="1">
			<title>View Contract</title>

			<para>
				The <literal>update</literal> method must adhere to the following conventions, to prevent memory leaks and to enable correct behavior within the engine:
			</para>

			<itemizedlist spacing="compact">
				<listitem>
					<para>
						A view implementation that posts events to the insert stream must post unique <literal>EventBean</literal> object references as insert stream events, and cannot post the same <literal>EventBean</literal> object reference multiple times. The underlying event to the <literal>EventBean</literal> object reference can be the same object reference, however the <literal>EventBean</literal> object reference posted by the view into the insert stream must be a new instance for each insert stream event.
					</para>
				</listitem>
				<listitem>
					<para>
						If the custom view posts a continuous insert stream, then the views must also post a continuous remove stream (second parameter to the <literal>updateChildren</literal> method). If the view does not post remove stream events, it assumes unbound keep-all semantics.
					</para>
				</listitem>
				<listitem>
					<para>
						<literal>EventBean</literal> events posted as remove stream events must be the same object reference as the <literal>EventBean</literal> events posted as insert stream by the view. Thus remove stream events posted by the view (the <literal>EventBean</literal> instances, does not affect the underlying representation) must be reference-equal to insert stream events posted by the view as part of an earlier invocation of the update method, or the same invocation of the update method.
					</para>
				</listitem>
				<listitem>
					<para>
						<literal>EventBean</literal> events represent a unique observation. The values of the observation can be the same, thus the underlying representation of an <literal>EventBean</literal> event can be reused, however event property values must be kept immutable and not be subject to change.
					</para>
				</listitem>
				<listitem>
					<para>
						Array elements of the insert and remove stream events must not carry null values. Array size must match the number of <literal>EventBean</literal> instances posted. It is recommended to use a <literal>null</literal> value for no insert or remove stream events rather then an empty zero-size array. 
					</para>
				</listitem>
			</itemizedlist>

			<para>
				Your view implementation can register a callback indicating when a statement using the view, or a context partition using the view, is stopped or terminated. Your
				view code must implement, or provide an implementation, of the <literal>com.espertech.esper.util.StopCallback</literal> interface. Register the stop callback in order for the engine to invoke the callback:
			</para>			
			<programlisting><![CDATA[agentInstanceContext.getTerminationCallbacks().add(this);]]></programlisting>

			<para>
				Please refer to the sample views for a code sample on how to implement the <literal>iterator</literal> method.
			</para>

			<para>
				In terms of multiple threads accessing view state, there is no need for your custom view factory or view implementation to perform any synchronization to protect internal state. The iterator of the custom view implementation does also not need to be thread-safe. The engine ensures the custom view executes in the context of a single thread at a time. If your view uses shared external state, such external state must be still considered for synchronization when using multiple threads.
			</para>
		</sect2>
		
		<sect2 xml:id="custom-views-config" revision="1">
			<title>Configuring View Namespace and Name</title>
			
			<para>
				The view factory class name as well as the view namespace and name for the new view must be added to the engine configuration via the configuration API or using the XML configuration file. The configuration shown below is XML however the same options are available through the configuration API:
			</para>
		
			<programlisting><![CDATA[<esper-configuration
  <plugin-view namespace="custom" name="ohlc" 
      factory-class="com.espertech.esper.example.ohlc.OHLCBarPlugInViewFactory" /> 
</esper-configuration>]]></programlisting>

			<para>
				The new view is now ready to use in a statement:
			</para>		
			<programlisting><![CDATA[select * from StockTick.custom:ohlc(timestamp, price)]]></programlisting>

			<para>
				Note that the view must implement additional interfaces if it acts as a data window view, or works in a grouping context, as discussed in detail below.
			</para>		
		</sect2>

		<sect2 xml:id="custom-views-datawin" revision="1">
			<title>Requirement for Data Window Views</title>
			
			<para>
				Your custom view may represent an expiry policy and may retain events and thus act as a data window view. In order to allow the engine to validate that your view can be used with named windows, which allow only data window views,
				this section documents any additional requirement that your classes must fulfill.
			</para>
		
			<para>
				Your view factory class must implement the <literal>com.espertech.esper.view.DataWindowViewFactory</literal> interface. This marker interface (no methods required) indicates that your view factory provides only data window views.  
			</para>		

			<para>
				Your view class must implement the <literal>com.espertech.esper.view.DataWindowView</literal> interface. This interface indicates that your view is a data window view and therefore eligible to be used in any construct that requires a data window view. The <literal>DataWindowView</literal> interface extends the <literal>ViewDataVisitable</literal> interface. Please provide an empty implementation method for the <literal>visitView</literal> method as required by <literal>ViewDataVisitable</literal> (the default behavior is sufficient).
			</para>
		</sect2>

		<sect2 xml:id="custom-views-derivedvalue" revision="1">
			<title>Requirement for Derived-Value Views</title>
			
			<para>
				Your custom view may compute derived information from the arriving stream, instead of retaining events, and thus act as a derived-value view. 
			</para>
		
			<para>
				Your view class should implement the <literal>com.espertech.esper.view.DerivedValueView</literal> interface. This marker interface indicates that your view is a derived-value view,
				affecting correct behavior of the view when used in joins.
			</para>
		</sect2>

		<sect2 xml:id="custom-views-grouped" revision="1">
			<title>Requirement for Grouped Views</title>
			
			<para>
				Grouped views are views that operate under the <literal>#groupwin</literal> view. When operating under <literal>#groupwin</literal>, the engine instantiates a single instance when the statement starts, and a new instance per group criteria dynamically as new group criteria become known. 
			</para>
		
			<para>
				The next statement shows EPL for using a view instance per grouping criteria:
			</para>		
			<programlisting><![CDATA[select * from StockTick#groupwin(symbol).custom:trendspotter(price)]]></programlisting>

			<para>
				Your view must implement the <literal>com.espertech.esper.view.GroupableView</literal> interface to indicate that the view can handle grouped windows.
			</para>		
		</sect2>
    </sect1>

    <sect1 xml:id="custom-aggregation-function" revision="1">
        <title>Aggregation Function</title>
        
		<indexterm><primary>plug-in</primary><secondary>custom aggregation function</secondary></indexterm>
		<indexterm><primary>aggregation functions</primary><secondary>custom plug-in</secondary></indexterm>
		
		<para>
		  Aggregation functions are stateful functions that aggregate events, event property values or expression results. Examples for built-in aggregation functions are <literal>count(*)</literal>, <literal>sum(price * volume)</literal>, <literal>window(*)</literal> or <literal>maxby(volume)</literal>.
		</para>
		
        <para>
		  Esper allows two different ways for your application to provide aggregation functions. We use the name <emphasis>aggregation single-function</emphasis> and <emphasis>aggregation multi-function</emphasis> for the two independent extension APIs for aggregation functions.			
        </para>

		<para>
			The aggregation single-function API is simple to use however it imposes certain restrictions on how expressions that contain aggregation functions share state and are evaluated.
		</para>

		<para>
			The aggregation multi-function API is more powerful and provides control over how expressions that contain aggregation functions share state and are evaluated.
		</para>
        
        <para>
		  The next table compares the two aggregation function extension API's:
        </para>
        
        <table frame="topbot">
			<title>Aggregation Function Extension API's</title>
			<tgroup cols="3">
				<colspec colwidth="1*"/>
				<colspec colwidth="1.5*"/>
				<colspec colwidth="1.5*"/>
				<thead>
					<row>
						<entry></entry>
						<entry>Single-Function</entry>
						<entry>Multi-Function</entry>
					</row>
				</thead>
				<tbody>
					<row>
						<entry>Return Value</entry>
						<entry>Can only return a single value or object. Cannot return an <literal>EventBean</literal> event, collection of <literal>EventBean</literal> events or collection or array of values for use with enumeration methods, for example.</entry>
						<entry>Can return an <literal>EventBean</literal> event, a collection of <literal>EventBean</literal> events or a collection or array of objects for use with enumeration methods or to access event properties.</entry>
					</row>
					<row>
						<entry>Complexity of API</entry>
						<entry>Simple (consists of 2 interfaces).</entry>
						<entry>More complex (consists of 6 interfaces).</entry>
					</row>
					<row>
						<entry>State Sharing</entry>
						<entry>State and parameter evaluation shared if multiple aggregation functions of the same name in the same statement (and context partition) take the exact same parameter expressions.</entry>
						<entry>State and parameter evaluation sharable when multiple aggregation functions of a related name (related thru configuration) for the same statement (and context partition) exist, according to a sharing-key provided by your API implementation.</entry>
					</row>
					<row>
						<entry>Function Name</entry>
						<entry>Each aggregation function expression receives its own factory object.</entry>
						<entry>Multiple related aggregation function expressions share a single factory object.</entry>
					</row>
					<row>
						<entry>Distinct Keyword</entry>
						<entry>Handled by the engine transparently.</entry>
						<entry>Indicated to the API implementation only.</entry>
					</row>
				</tbody>
			</tgroup>
		</table> 
		
		<para>
		  The following sections discuss developing an aggregation single-function first, followed by the subject of developing an aggregation multi-function.
		</para>
		
		<note>
			<para>
			  The aggregation multi-function API is a powerful and lower-level API to extend the engine. Any classes that are not part of the <literal>client</literal>, <literal>plugin</literal> or <literal>agg.access</literal> package are subject to change between minor and major releases of the engine.
			</para>
		</note>
        
		<sect2 xml:id="custom-aggregation-single" revision="1">
			<title>Aggregation Single-Function Development</title>

			<para>
				This section describes the <emphasis>aggregation single-function</emphasis> extension API for providing aggregation functions.
			</para>

			<para>
				The following steps are required to develop and use a custom aggregation single-function with Esper. 
			</para>
				
			<orderedlist spacing="compact">
				<listitem>
					<para>
						Implement an aggregation function factory by implementing the interface <literal>com.espertech.esper.client.hook.AggregationFunctionFactory</literal>.
					</para>
				</listitem>
				<listitem>
					<para>
						Implement an aggregation function by implementing the interface <literal>com.espertech.esper.epl.agg.aggregator.AggregationMethod</literal>.
					</para>
				</listitem>
				<listitem>
					<para>
						Register the aggregation single-function factory class with the engine by supplying a function name, via the engine configuration file or the runtime and static configuration API.
					</para>
				</listitem>
			</orderedlist>
	
			<para>
				The optional keyword <literal>distinct</literal> ensures that only distinct (unique) values are aggregated and duplicate values are ignored by the aggregation function. Custom plug-in aggregation single-functions do not need to implement the logic to handle <literal>distinct</literal> values. This is because when the engine encounters the <literal>distinct</literal> keyword, it eliminates any non-distinct values before passing the value for aggregation to the custom aggregation single-function.
			</para>

			<para>
				Custom aggregation functions can also be passed multiple parameters, as further described in <xref linkend="custom-aggregation-single-multiparam"/>. In the example below the aggregation function accepts a single parameter.
			</para>
	
			<para>
				The code for the example aggregation function as shown in this chapter can be found in the runtime configuration example in the package <literal>com.espertech.esper.example.runtimeconfig</literal> by the name <literal>MyConcatAggregationFunction</literal>. The sample function simply concatenates string-type values.
			</para>

			<sect3 xml:id="custom-aggregation-single-factory" revision="1">
				<title>Implementing an Aggregation Single-Function Factory</title>
			
				<para>
					An aggregation function factory class is responsible for the following functions:
				</para>
				<itemizedlist spacing="compact">
					<listitem>
						<para>
							Implement a <literal>setFunctionName</literal> method that receives the function name assigned to this instance. 
						</para>
					</listitem>
					<listitem>
						<para>
							Implement a <literal>validate</literal> method that validates the value type of the data points that the function must process.
						</para>
					</listitem>
					<listitem>
						<para>
							Implement a <literal>getValueType</literal> method that returns the type of the aggregation value generated by the aggregation function instances. For example, the built-in <literal>count</literal> aggregation function returns <literal>Long.class</literal> as it generates <literal>long</literal> -typed values.
						</para>
					</listitem>
					<listitem>
						<para>
							Implement a <literal>newAggregator</literal> method that instantiates and returns an aggregation function instance. 
						</para>
					</listitem>
				</itemizedlist>

				<para>
					Aggregation function classes implement the interface <literal>com.espertech.esper.client.hook.AggregationFunctionFactory</literal>:
				</para>
				<programlisting><![CDATA[public class MyConcatAggregationFunctionFactory implements AggregationFunctionFactory { ...]]></programlisting>
	
				<para>
					The engine generally constructs one instance of the aggregation function factory class for each time the function is listed in an EPL statement, however the engine may decide to reduce the number of aggregation class instances if it finds equivalent aggregations.
				</para>
	
				<para>
					The aggregation function factory instance receives the aggregation function name via set <literal>setFunctionName</literal> method.
				</para>
				
				<para>
				  The sample concatenation function factory provides an empty <literal>setFunctionName</literal> method:
				</para>
				<programlisting><![CDATA[public void setFunctionName(String functionName) {
  // no action taken
}]]></programlisting>

				<para>
					An aggregation function factory must provide an implementation of the <literal>validate</literal> method that is passed a <literal>AggregationValidationContext</literal> validation context object. Within the validation context you find the result type of each of the parameters expressions to the aggregation function as well as information about constant values and data window use. Please see the JavaDoc API documentation for a comprehensive list of validation context information.
				</para>
					
				<para>
					Since the example concatenation function requires string types, it implements a type check:
				</para>
				<programlisting><![CDATA[public void validate(AggregationValidationContext validationContext) {
  if ((validationContext.getParameterTypes().length != 1) ||
    (validationContext.getParameterTypes()[0] != String.class)) {
    throw new IllegalArgumentException("Concat aggregation requires a single parameter of type String");
  }
}]]></programlisting>

				<para>
					In order for the engine to validate the type returned by the aggregation function against the types expected by enclosing expressions, the <literal>getValueType</literal> must return the result type of any values produced by the aggregation function:
				</para>
				<programlisting><![CDATA[public Class getValueType() {
  return String.class;
}]]></programlisting>

				<para>
					 Finally the factory implementation must provide a <literal>newAggregator</literal> method that returns instances of <literal>AggregationMethod</literal>. The engine invokes this method for each new aggregation state to be allocated.
				</para>
				<programlisting><![CDATA[public AggregationMethod newAggregator() {
  return new MyConcatAggregationFunction();
}]]></programlisting>

			</sect3>

			<sect3 xml:id="custom-aggregation-single implementing" revision="1">
				<title>Implementing an Aggregation Single-Function</title>
			
				<para>
					An aggregation function class is responsible for the following functions:
				</para>
				<itemizedlist spacing="compact">
					<listitem>
						<para>
							Implement an <literal>enter</literal> method that the engine invokes to add a data point into the aggregation, when an event enters a data window
						</para>
					</listitem>
					<listitem>
						<para>
							Implement a <literal>leave</literal> method that the engine invokes to remove a data point from the aggregation, when an event leaves a data window
						</para>
					</listitem>
					<listitem>
						<para>
							Implement a <literal>getValue</literal> method that returns the current value of the aggregation. 
						</para>
					</listitem>
					<listitem>
						<para>
							Implement a <literal>clear</literal> method that resets the current value. 
						</para>
					</listitem>
				</itemizedlist>
	
				<para>
					Aggregation function classes implement the interface <literal>AggregationMethod</literal>:
				</para>
				<programlisting><![CDATA[public class MyConcatAggregationFunction implements AggregationMethod { ...]]></programlisting>
	
				<para>
					The class that provides the aggregation and implements <literal>AggregationMethod</literal> does not have to be threadsafe.
				</para>
	
				<para>
					The constructor initializes the aggregation function:
				</para>
				<programlisting><![CDATA[public class MyConcatAggregationFunction implements AggregationMethod {
  private final static char DELIMITER = ' ';
  private StringBuilder builder;
  private String delimiter;

  public MyConcatAggregationFunction() {
    builder = new StringBuilder();
    delimiter = "";
  }
  ...]]></programlisting>

				<para>
					The <literal>enter</literal> method adds a datapoint to the current aggregation value. The example <literal>enter</literal> method shown below adds a delimiter and the string value to a string buffer:
				</para>
				<programlisting><![CDATA[public void enter(Object value) {
  if (value != null) {
    builder.append(delimiter);
    builder.append(value.toString());
    delimiter = String.valueOf(DELIMITER);
  }
}]]></programlisting>

				<para>
					Conversly, the <literal>leave</literal> method removes a datapoint from the current aggregation value. The example <literal>leave</literal> method removes from the string buffer:
				</para>
				<programlisting><![CDATA[public void leave(Object value) {
  if (value != null) {
    builder.delete(0, value.toString().length() + 1);
  }
}]]></programlisting>

				<para>
					Finally, the engine obtains the current aggregation value by means of the <literal>getValue</literal> method:
				</para>
				<programlisting><![CDATA[public Object getValue() {
  return builder.toString();
}]]></programlisting>

				<para>
					For on-demand queries the aggregation function must support resetting its value to empty or start values. Implement the <literal>clear</literal> function to reset the value as shown below:
				</para>
				<programlisting><![CDATA[public void clear() {
  builder = new StringBuilder();
  delimiter = "";
}]]></programlisting>
			</sect3>

			<sect3 xml:id="custom-aggregation-single-config" revision="1">
				<title>Configuring the Aggregation Single-Function Name</title>
			
				<para>
					The aggregation function class name as well as the function name for the new aggregation function must be added to the engine configuration via the configuration API or using the XML configuration file. The configuration shown below is XML however the same options are available through the configuration API:
				</para>
			
				<programlisting><![CDATA[<esper-configuration
  <plugin-aggregation-function name="concat" 
    factory-class="com.espertech.esper.example.runtimeconfig.MyConcatAggregationFunctionFactory" />
</esper-configuration>]]></programlisting>

				<para>
					The new aggregation function is now ready to use in a statement:
				</para>		
				<programlisting><![CDATA[select concat(symbol) from StockTick#length(3)]]></programlisting>
	
			</sect3>

			<sect3 xml:id="custom-aggregation-single-multiparam" revision="1">
				<title>Aggregation Single-Function: Accepting Multiple Parameters</title>
				
				<para>
					Your plug-in aggregation function may accept multiple parameters, simply by casting the Object parameter of the <literal>enter</literal> and <literal>leave</literal> method to <literal>Object[]</literal>.
				</para>
			
				<para>
					For instance, assume an aggregation function <literal>rangeCount</literal> that counts all values that fall into a range of values. The EPL that calls this function and provides a lower and upper bounds of 1 and 10 is:
				</para>
				<programlisting><![CDATA[select rangeCount(1, 10, myValue) from MyEvent]]></programlisting>

				<para>
					The <literal>enter</literal> method of the plug-in aggregation function may look as follows:
				</para>
				<programlisting><![CDATA[public void enter(Object value)  {
  Object[] params = (Object[]) value;
  int lower = (Integer) params[0];
  int upper = (Integer) params[1];
  int val = (Integer) params[2];
  if ((val >= lower) && (val <= upper)) {
    count++;
  }
}]]></programlisting>

				<para>
					Your plug-in aggregation function may want to validate parameter types or may want to know which parameters are constant-value expressions. Constant-value expressions are evaluated only once by the engine and could
					therefore be cached by your aggregation function for performance reasons. The engine provides constant-value information as part of the <literal>AggregationValidationContext</literal> passed to the <literal>validate</literal> method.
				</para>
			</sect3>

			<sect3 xml:id="custom-aggregation-single-filter" revision="1">
				<title>Aggregation Single-Function: The Filter Parameter</title>
				
				<para>
					When an EPL statement provides the <literal>filter</literal> named parameter the value of the filter expression is a <literal>boolean</literal>-type value
					that the engine determines and provides to your <literal>enter</literal> method as the last value in the parameter array.
				</para>
			
				<para>
					For instance, assume an aggregation function <literal>concat</literal> that receives a <literal>word</literal> value and that has a <literal>filter</literal> expression as parameters:
				</para>
				<programlisting><![CDATA[select concat(word, filter: word not like '%jim%') from MyWordEvent]]></programlisting>

				<para>
					The <literal>enter</literal> method of the plug-in aggregation function may look as follows:
				</para>
				<programlisting><![CDATA[public void enter(Object value)  {
  Object[] arr = (Object[]) value;
  Boolean pass = (Boolean) arr[1];
  if (pass != null && pass) {
    buffer.append(arr[0].toString());
  }
}]]></programlisting>

				<para>
					Your code can obtain the actual filter expression from the <literal>AggregationValidationContext</literal> that is passed to the <literal>validate</literal> method and that 
					returns the named parameters via <literal>getNamedParameters</literal>.
				</para>
			</sect3>

			<sect3 xml:id="custom-aggregation-single-dotmethod" revision="1">
				<title>Aggregation Single-Function: Dot-Operator Use</title>
				<para>
					When the custom aggregation function returns an object as a return value, the EPL can use parenthesis and the dot-operator to invoke methods on the return value.
				</para>
				<para>
					The following example assumes that the <literal>myAggregation</literal> custom aggregation function returns an object that has <literal>getValueOne</literal> and <literal>getValueTwo</literal> methods:
				</para>
				<programlisting><![CDATA[select (myAggregation(myValue)).getValueOne(),  (myAggregation(myValue)).getValueTwo() from MyEvent]]></programlisting>
				<para>
					Since the above EPL aggregates the same value, the engine internally uses a single aggregation to represent the current value of <literal>myAggregation</literal> (and not two instances of the aggregation, even though <literal>myAggregation</literal> is listed twice).
				</para>
			</sect3>
		</sect2>

	    <!--
		    BEGIN Aggregation Multi-function
		  -->
		<sect2 xml:id="custom-aggregation-multi" revision="1">
			<title>Aggregation Multi-Function Development</title>
			
			<para>
				This section introduces the aggregation multi-function API. Please refer to the JavaDoc for more complete class and method-level documentation.
			</para>

			<para>
				Among the Esper examples is an example use of the aggregation multi-function API in the example by name Cycle-Detect. 
				Cycle-Detect takes incoming transaction events that have from-account and to-account fields.
				The example detects a cycle in the transactions between accounts in order to detect a possible transaction fraud. 
				Please note that the graph and cycle detection logic of the example is not part of Esper:
				The example utilizes the <literal>jgrapht</literal> library.
			</para>

			<para>
				In the Cycle-Detect example, the vertices of a graph are the account numbers. For example the account numbers <literal>Acct-1</literal>, <literal>Acct-2</literal> and <literal>Acct-3</literal>.
				In the graph the edges are transaction events that identify a from-account and a to-account. An example edge is <literal>{from:Acct-1, to:Acct-2}</literal>.
				An example cycle is therefore in the three transactions <literal>{from:Acct-1, to:Acct-2}</literal>, <literal>{from:Acct-2, to:Acct-3}</literal> and <literal>{from:Acct-3, to:Acct-1}</literal>.
			</para>

			<para>
				The code for the example aggregation multi-function as shown in this chapter can be found in the Cycle-Detect example in the package <literal>com.espertech.esper.example.cycledetect</literal>.
				The example provides two aggregation functions named <literal>cycledetected</literal> and <literal>cycleoutput</literal>:
			</para>
			
			<orderedlist>
				<listitem>
					<para>
					  The <literal>cycledetected</literal> function returns a boolean value whether a graph cycle is found or not.
					</para>
				</listitem>
				<listitem>
					<para>
					  The <literal>cycleoutput</literal> function outputs the vertices (account numbers) that are part of the graph cycle.
					</para>
				</listitem>
			</orderedlist>

			<para>
			  In the Cycle-Detect example, the following statement utilizes the two functions <literal>cycledetected</literal> and <literal>cycleoutput</literal> that
			  share the same graph state to detect a cycle among the last 1000 events:
			</para>
			<programlisting><![CDATA[@Name('CycleDetector') select cycleoutput() as cyclevertices
from TransactionEvent#length(1000)
having cycledetected(fromAcct, toAcct)]]></programlisting>

			<para>
			  If instead the goal is to run graph cycle detection every 1 second (and not upon arrival of a new event), this sample EPL statement uses a pattern to trigger cycle detection:
			</para>
			<programlisting><![CDATA[@Name('CycleDetector')
select (select cycleoutput(fromAcct, toAcct) from TransactionEvent#length(1000)) as cyclevertices
from pattern [every timer:interval(1)]]]></programlisting>

			<para>
				The following steps are required to develop and use a custom aggregation multi-function with Esper. 
			</para>
				
			<orderedlist spacing="compact">
				<listitem>
					<para>
						Implement an aggregation multi-function factory by implementing the interface <literal>com.espertech.esper.plugin.PlugInAggregationMultiFunctionFactory</literal>.
					</para>
				</listitem>
				<listitem>
					<para>
						Implement one or more handlers for aggregation functions by implementing the interface <literal>com.espertech.esper.plugin.PlugInAggregationMultiFunctionHandler</literal>.
					</para>
				</listitem>
				<listitem>
					<para>
						Implement an aggregation state key by implementing the interface <literal>com.espertech.esper.epl.agg.access.AggregationStateKey</literal>.
					</para>
				</listitem>
				<listitem>
					<para>
						Implement an aggregation state factory by implementing the interface <literal>com.espertech.esper.plugin.PlugInAggregationMultiFunctionStateFactory</literal>.
					</para>
				</listitem>
				<listitem>
					<para>
						Implement an aggregation state holder by implementing the interface <literal>com.espertech.esper.epl.agg.access.AggregationState</literal>.
					</para>
				</listitem>
				<listitem>
					<para>
						Implement a state accessor by implementing the interface <literal>com.espertech.esper.epl.agg.access.AggregationAccessor</literal>.
					</para>
				</listitem>
				<listitem>
					<para>
						Register the aggregation multi-function factory class with the engine by supplying one or more function names, via the engine configuration file or the runtime and static configuration API.
					</para>
				</listitem>
			</orderedlist>
	
			<sect3 xml:id="custom-aggregation-multi-factory" revision="1">
				<title>Implementing an Aggregation Multi-Function Factory</title>
			
				<para>
					An aggregation multi-function factory class is responsible for the following functions:
				</para>
				<itemizedlist spacing="compact">
					<listitem>
						<para>
							Implement the <literal>addAggregationFunction</literal> method that receives an invocation for each aggregation function declared in the statement that matches any of the function names provided at configuration time. 
						</para>
					</listitem>
					<listitem>
						<para>
							Implement the <literal>validateGetHandler</literal> method that receives an invocation for each aggregation function to be validated in the statement that matches any of the function names provided at configuration time.
						</para>
					</listitem>
				</itemizedlist>

				<para>
					Aggregation multi-function factory classes implement the interface <literal>com.espertech.esper.plugin.PlugInAggregationMultiFunctionFactory</literal>:
				</para>
				<programlisting><![CDATA[public class CycleDetectorAggregationFactory implements PlugInAggregationMultiFunctionFactory { ...]]></programlisting>
	
				<para>
					The engine constructs a single instance of the aggregation multi-function factory class that is shared for all aggregation function expressions in a statement that have one of the function names provided in the configuration object.
				</para>
	
				<para>
					The engine invokes the <literal>addAggregationFunction</literal> method at the time it parses an EPL statement or compiles a statement object model (SODA API).
					The method receives a declaration-time context object that provides the function name as well as additional information.
				</para>
				
				<para>
				  The sample Cycle-Detect factory class provides an empty <literal>addAggregationFunction</literal> method:
				</para>
				<programlisting><![CDATA[public void addAggregationFunction(PlugInAggregationMultiFunctionDeclarationContext declarationContext) {
  // no action taken
}]]></programlisting>

				<para>
					The engine invokes the <literal>validateGetHandler</literal> method at the time of expression validation. It passes 
					a <literal>PlugInAggregationMultiFunctionValidationContext</literal> validation context object that contains actual parameters expressions. 
					Please see the JavaDoc API documentation for a comprehensive list of validation context information.
				</para>
					
				<para>
					The <literal>validateGetHandler</literal> method must return a handler object the implements the <literal>PlugInAggregationMultiFunctionHandler</literal> interface.
					Return a handler object for each aggregation function expression according to the aggregation function name and its parameters that are provided in the validation 
					context.
				</para>

				<para>
					The example <literal>cycledetect</literal> function takes two parameters that provide the cycle edge (from-account and to-account):
				</para>
				<programlisting><![CDATA[public PlugInAggregationMultiFunctionHandler validateGetHandler(PlugInAggregationMultiFunctionValidationContext validationContext) {
  if (validationContext.getParameterExpressions().length == 2) {
    fromExpression = validationContext.getParameterExpressions()[0].getExprEvaluator();
    toExpression = validationContext.getParameterExpressions()[1].getExprEvaluator();
  }
  return new CycleDetectorAggregationHandler(this, validationContext);
}]]></programlisting>
			</sect3>

			<sect3 xml:id="custom-aggregation-multi-handlr" revision="1">
				<title>Implementing an Aggregation Multi-Function Handler</title>
			
				<para>
					An aggregation multi-function handler class must implement the <literal>PlugInAggregationMultiFunctionHandler</literal> interface and is responsible for the following functions:
				</para>
				
				<itemizedlist spacing="compact">
					<listitem>
						<para>
							Implement the <literal>getAccessor</literal> method that returns a reader object for the aggregation state.
						</para>
					</listitem>
					<listitem>
						<para>
							Implement the <literal>getReturnType</literal> method that returns information about the type of return values provided by the accessor reader object.
						</para>
					</listitem>
					<listitem>
						<para>
							Implement the <literal>getAggregationStateUniqueKey</literal> method that provides a key object used by the engine to determine which aggregation functions share state. 
						</para>
					</listitem>
					<listitem>
						<para>
							Implement the <literal>getStateFactory</literal> method that returns a state factory object that the engine invokes, when required, to instantiate aggregation state holders.
						</para>
					</listitem>
				</itemizedlist>

				<para>
					Typically your API returns a handler instance for each aggregation function in an EPL statement expression.
				</para>

				<para>
					In the Cycle-Detect example, the class <literal>CycleDetectorAggregationHandler</literal> is the handler for all aggregation functions.
				</para>
				<programlisting><![CDATA[public class CycleDetectorAggregationHandler implements PlugInAggregationMultiFunctionHandler { ...]]></programlisting>
	
				<para>
				  The <literal>getAccessor</literal> methods return a reader object according to whether the aggregation function name is <literal>cycledetected</literal> or <literal>cycleoutput</literal>:
				</para>
				<programlisting><![CDATA[public AggregationAccessor getAccessor() {
  if (validationContext.getFunctionName().toLowerCase().equals(CycleDetectorConstant.CYCLEOUTPUT_NAME)) {
    return new CycleDetectorAggregationAccessorOutput();
  }
  return new CycleDetectorAggregationAccessorDetect();
}]]></programlisting>

				<para>
				  The <literal>getReturnType</literal> method provided by the handler instructs the engine about the return type of each aggregation accessor.
				  The class <literal>com.espertech.esper.client.util.ExpressionReturnType</literal> holds return type information.
				</para>

				<para>
					In the Cycle-Detect example the <literal>cycledetected</literal> function returns a single boolean value. The <literal>cycleoutput</literal> returns a collection of vertices:
				</para>			
				<programlisting><![CDATA[public ExpressionReturnType getReturnType() {
  if (validationContext.getFunctionName().toLowerCase().equals(CycleDetectorConstant.CYCLEOUTPUT_NAME)) {
    return ExpressionReturnType.collectionOfSingleValue(factory.getFromExpression().getType());
  }
  return ExpressionReturnType.singleValue(Boolean.class) ;
}]]></programlisting>
					
				<para>
					The engine invokes the <literal>getAggregationStateUniqueKey</literal> method to determine whether multiple aggregation function expressions
					in the same statement can share the same aggregation state or should receive different aggregation state instances.
				</para>
				
				<para>
					The <literal>getAggregationStateUniqueKey</literal> method must return an instance of <literal>AggregationStateKey</literal>.
					The engine uses equals-semantics (the <literal>hashCode</literal> and <literal>equals</literal> methods) to determine whether multiple aggregation function share the state object.
					If the key object returned for each aggregation function by the handler is an equal key object then the engine shares aggregation 
					state between such aggregation functions for the same statement and context partition.
				</para>

				<para>
				  In the Cycle-Detect example the state is shared, which it achieves by simply returning the same key instance:
				</para>
				<programlisting><![CDATA[private static final AggregationStateKey CYCLE_KEY = new AggregationStateKey() {};

public AggregationStateKey getAggregationStateUniqueKey() {
  return CYCLE_KEY;   // Share the same aggregation state instance
}]]></programlisting>

				<para>
				  The engine invokes the <literal>getStateFactory</literal> method to obtain an instance of <literal>PlugInAggregationMultiFunctionStateFactory</literal>. The 
				  state factory is responsible to instantiating separate aggregation state instances. If you statement does not have a <literal>group by</literal> clause,
				  the engine obtains a single aggregation state from the state factory. If your statement has a <literal>group by</literal> clause, the engine obtains
				  an aggregation state instance for each group when it encounters a new group. 
				</para>
				
				<para>
				  In the Cycle-Detect example the method passes the expression evaluators providing the from-account and to-account expressions to the state factory:
				</para>
				<programlisting><![CDATA[public PlugInAggregationMultiFunctionStateFactory getStateFactory() {
  return new CycleDetectorAggregationStateFactory(factory.getFromExpression(), factory.getToExpression());
}]]></programlisting>
			</sect3>

			<sect3 xml:id="custom-aggregation-multi-statefactory" revision="1">
				<title>Implementing an Aggregation Multi-Function State Factory</title>
			
				<para>
					An aggregation multi-function state factory class must implement the <literal>PlugInAggregationMultiFunctionStateFactory</literal> interface and is responsible for the following functions:
				</para>
				
				<itemizedlist spacing="compact">
					<listitem>
						<para>
							Implement the <literal>makeAggregationState</literal> method that returns an aggregation state holder.
						</para>
					</listitem>
				</itemizedlist>

				<para>
					The engine invokes the <literal>makeAggregationState</literal> method to obtain a new aggregation state instance before applying aggregation state. 
					If using <literal>group by</literal> in your statement, the engine invokes the <literal>makeAggregationState</literal> method to obtain a state holder for each group.
				</para>

				<para>
					In the Cycle-Detect example, the class <literal>CycleDetectorAggregationStateFactory</literal> is the state factory for all aggregation functions:
				</para>
				<programlisting><![CDATA[public class CycleDetectorAggregationStateFactory implements PlugInAggregationMultiFunctionStateFactory {
  private final ExprEvaluator fromEvaluator;
  private final ExprEvaluator toEvaluator;

  public CycleDetectorAggregationStateFactory(ExprEvaluator fromEvaluator, ExprEvaluator toEvaluator) {
    this.fromEvaluator = fromEvaluator;
    this.toEvaluator = toEvaluator;
  }

  public AggregationState makeAggregationState(PlugInAggregationMultiFunctionStateContext stateContext) {
    return new CycleDetectorAggregationState(this);
  }

  public ExprEvaluator getFromEvaluator() {
    return fromEvaluator;
  }

  public ExprEvaluator getToEvaluator() {
    return toEvaluator;
  }
}]]></programlisting>	
			</sect3>

			<sect3 xml:id="custom-aggregation-multi-state" revision="1">
				<title>Implementing an Aggregation Multi-Function State</title>
			
				<para>
					An aggregation multi-function state class must implement the <literal>AggregationState</literal> interface and is responsible for the following functions:
				</para>
				
				<itemizedlist spacing="compact">
					<listitem>
						<para>
							Implement the <literal>applyEnter</literal> method that enters events, event properties or computed values.
						</para>
					</listitem>
					<listitem>
						<para>
							Optionally implement the <literal>applyLeave</literal> method that can remove events or computed values.
						</para>
					</listitem>
					<listitem>
						<para>
							Implement the <literal>clear</literal> method to clear state. 
						</para>
					</listitem>
				</itemizedlist>

				<para>
					In the Cycle-Detect example, the class <literal>CycleDetectorAggregationState</literal> is the state for all aggregation functions.
					Please review the example for more information.
				</para>
			</sect3>

			<sect3 xml:id="custom-aggregation-multi-accessor" revision="1">
				<title>Implementing an Aggregation Multi-Function Accessor</title>
			
				<para>
					An aggregation multi-function accessor class must implement the <literal>AggregationAccessor</literal> interface and is responsible for the following functions:
				</para>
				
				<itemizedlist spacing="compact">
					<listitem>
						<para>
							Implement the <literal>Object getValue(AggregationState state)</literal> method that returns a result object for the aggregation state.
						</para>
					</listitem>
					<listitem>
						<para>
							Implement the <literal>Collection&lt;EventBean&gt; getEnumerableEvents(AggregationState state)</literal> method that returns a collection of events for enumeration,
							if applicable (or null).
						</para>
					</listitem>
					<listitem>
						<para>
							Implement the <literal>EventBean getEnumerableEvent(AggregationState state)</literal> method that returns an event, if applicable (or null).
						</para>
					</listitem>
				</itemizedlist>

				<para>
					In the Cycle-Detect example, the class <literal>CycleDetectorAggregationAccessorDetect</literal> returns state for the <literal>cycledetected</literal> aggregation function
					and the <literal>CycleDetectorAggregationAccessorOutput</literal> returns the state for the <literal>cycleoutput</literal> aggregation function.
				</para>
			</sect3>
			
			<sect3 xml:id="custom-aggregation-multi-config" revision="1">
				<title>Configuring the Aggregation Multi-Function Name</title>
			
				<para> 
				  An aggregation multi-function configuration can receive one or multiple function names. You must also set a factory class name.
				</para>
				
				<para>
				  The sample XML snippet below configures an aggregation multi-function that is associated with the function names <literal>func1</literal> and <literal>func2</literal>.
				</para>
			
				<programlisting><![CDATA[<esper-configuration
  <plugin-aggregation-multifunction 
      function-names="cycledetected,cycleoutput"   // a comma-separated list of function name
      factory-class="com.espertech.esper.example.cycledetect.CycleDetectorAggregationFactory"/>
</esper-configuration>]]></programlisting>

				<para>
				  The next example uses the runtime configuration API to register the same:
				</para>
			
				<programlisting><![CDATA[String[] functionNames = new String[] {"cycledetected", "cycleoutput"};
ConfigurationPlugInAggregationMultiFunction config = new ConfigurationPlugInAggregationMultiFunction(functionNames, CycleDetectorAggregationFactory.class.getName());
engine.getEPAdministrator().getConfiguration().addPlugInAggregationMultiFunction(config);]]></programlisting>
			</sect3>

			<sect3 xml:id="custom-aggregation-multi-threadsafety" revision="1">
				<title>Aggregation Multi-Function Thread Safety</title>
			
				<para>
					The engine shares an <literal>AggregationAccessor</literal> instance between threads. The accessor should be designed stateless and should not use any locking of any kind
					in the <literal>AggregationAccessor</literal> implementation unless your implementation uses other state.
					Since the engine passes an aggregation state instance to the accessor it is thread-safe as long as it relies only on the aggregation state passed to it.
				</para>

				<para>
					The engine does not share an <literal>AggregationState</literal> instance between threads. There is no need to use locking of any kind 
					in the <literal>AggregationState</literal> implementation unless your implementation uses other state.
				</para>
			</sect3>
			<sect3 xml:id="custom-aggregation-multi-table" revision="1">
				<title>Aggregation Multi-Function Use With Tables</title>
			
				<para>
					Tables allow columns to hold aggregation state including the state for multi-function aggregations. This section provides API pointers.
				</para>
				
				<para>
					When an EPL statement accesses a table column that declares aggregation state of a multi-function aggregation, the 
					<literal>PlugInAggregationMultiFunctionValidationContext</literal> contains an <literal>optionalTableColumnAccessed</literal> field that provides information
					about the table column.
				</para>
				
				<para>
					To find out the statement type, such as to determine whether the current statement is a <literal>create-table</literal> statement, use 
					<literal>context.getValidationContext().getExprEvaluatorContext().getStatementType()</literal>.
				</para>
				
				<para>
					To find out whether the statement aggregates into a table, use <literal>context.getValidationContext().getIntoTableName()</literal> that returns the table name or null if not aggregating into a table.
				</para>

				<para>
					The engine uses <literal>AggregationStateKey</literal> to determine whether an aggregation function listed with <literal>into table</literal> is compatible with the aggregation type 
					that a table column declares. The <literal>equals</literal> method of the object must return true for compatible and false for incompatible.
				</para>
			</sect3>

			<sect3 xml:id="custom-aggregation-multi-filter" revision="1">
				<title>Aggregation Multi-Function Use Filter Expression</title>
			
				<para>
					The <literal>filter</literal> expression is passed to you in <literal>PlugInAggregationMultiFunctionValidationContext</literal> as part of <literal>getNamedParameters</literal> under the name <literal>filter</literal>. When use with tables the filter expression is part of <literal>PlugInAggregationMultiFunctionAgentContext</literal>.
				</para>
				
				<para>
					Your application must invoke the filter expression as the engine does not evaluate the filter expression for you. For example:
				</para>
				<programlisting><![CDATA[ExprEvaluator filterEval = validationContext.getNamedParameters().get("filter").get(0).getExprEvaluator();]]></programlisting>
				<programlisting><![CDATA[public void applyEnter(EventBean[] eventsPerStream, ExprEvaluatorContext exprEvaluatorContext) {
  Boolean pass = (Boolean) filterEval.evaluate(eventsPerStream, true, exprEvaluatorContext); // note: pass "false" for applyLeave
  if (pass != null && pass) {
    Object value = valueEval.evaluate(eventsPerStream, true, exprEvaluatorContext); // note: pass "false" for applyLeave
    // do something
  }
}]]></programlisting>
			</sect3>
		</sect2>		
	</sect1>

    <sect1 xml:id="custom-pattern-guard" revision="1">
        <title>Pattern Guard</title>
        
		<indexterm><primary>plug-in</primary><secondary>custom pattern guard</secondary></indexterm>
		<indexterm><primary>pattern guard</primary><secondary>custom plug-in</secondary></indexterm>
        <para>
			Pattern guards are pattern objects that control the lifecycle of the guarded sub-expression, and can filter the events fired by the subexpression. 
        </para>
        
        <para>
			The following steps are required to develop and use a custom guard object with Esper. 
        </para>
			
		<orderedlist spacing="compact">
			<listitem>
				<para>
					Implement a guard factory class, responsible for creating guard object instances.
				</para>
			</listitem>
			<listitem>
				<para>
					Implement a guard class.
				</para>
			</listitem>
			<listitem>
				<para>
					Register the guard factory class with the engine by supplying a namespace and name, via the engine configuration file or the configuration API.
				</para>
			</listitem>
		</orderedlist>

        <para>
			The code for the example guard object as shown in this chapter can be found in the test source folder in the package <literal>com.espertech.esper.regression.client</literal> by the name <literal>MyCountToPatternGuardFactory</literal>. The sample guard discussed here counts the number of events occurring up to a maximum number of events, and end the sub-expression when that maximum is reached.
        </para>

		<sect2 xml:id="custom-pattern-guard-factory-implementing" revision="1">
			<title>Implementing a Guard Factory</title>
			
			<para>
				A guard factory class is responsible for the following functions:
			</para>
			<itemizedlist spacing="compact">
				<listitem>
					<para>
						Implement a <literal>setGuardParameters</literal> method that takes guard parameters, which are themselves expressions.
					</para>
				</listitem>
				<listitem>
					<para>
						Implement a <literal>makeGuard</literal> method that constructs a new guard instance.
					</para>
				</listitem>
			</itemizedlist>

			<para>
				Guard factory classes subclass <literal>com.espertech.esper.pattern.guard.GuardFactorySupport</literal>:
			</para>
			<programlisting><![CDATA[public class MyCountToPatternGuardFactory extends GuardFactorySupport { ...]]></programlisting>

			<para>
				The engine constructs one instance of the guard factory class for each time the guard is listed in a statement. 
			</para>
				
			<para>
				The guard factory class implements the <literal>setGuardParameters</literal> method that is passed the parameters to the guard as supplied by the statement. It verifies the guard parameters, similar to the code snippet shown next. Our example counter guard takes a single numeric parameter:
			</para>
			<programlisting><![CDATA[public void setGuardParameters(List<ExprNode> guardParameters, 
			MatchedEventConvertor convertor) throws GuardParameterException {
    String message = "Count-to guard takes a single integer-value expression as parameter";
    if (guardParameters.size() != 1) {
        throw new GuardParameterException(message);
    }

    if (guardParameters.get(0).getExprEvaluator().getType() != Integer.class) {
        throw new GuardParameterException(message);
    }

    this.numCountToExpr = guardParameters.get(0);
    this.convertor = convertor;
}]]></programlisting>

			<para>
				The <literal>makeGuard</literal> method is called by the engine to create a new guard instance. The example <literal>makeGuard</literal> method shown below passes the maximum count of events to the guard instance. It also passes a <literal>Quitable</literal> implementation to the guard instance. The guard uses <literal>Quitable</literal> to indicate that the sub-expression contained within must stop (quit) listening for events.
			</para>
			<programlisting><![CDATA[public Guard makeGuard(PatternAgentInstanceContext context,
      MatchedEventMap beginState, 
      Quitable quitable, 
      Object stateNodeId, 
      Object guardState) {
      
    Object parameter = PatternExpressionUtil.evaluate("Count-to guard", 
        beginState, numCountToExpr, convertor);
    if (parameter == null) {
        throw new EPException("Count-to guard parameter evaluated to a null value");
    }

    Integer numCountTo = (Integer) parameter;
    return new MyCountToPatternGuard(numCountTo, quitable);
}]]></programlisting>

		</sect2>

		<sect2 xml:id="custom-pattern-guard-implementing" revision="1">
			<title>Implementing a Guard Class</title>
			
			<para>
				A guard class has the following responsibilities:
			</para>
			<itemizedlist spacing="compact">
				<listitem>
					<para>
						Provides a <literal>startGuard</literal> method that initalizes the guard.
					</para>
				</listitem>
				<listitem>
					<para>
						Provides a <literal>stopGuard</literal> method that stops the guard, called by the engine when the whole pattern is stopped, or the sub-expression containing the guard is stopped.
					</para>
				</listitem>
				<listitem>
					<para>
						Provides an <literal>inspect</literal> method that the pattern engine invokes to determine if the guard lets matching events pass for further evaluation by the containing expression.
					</para>
				</listitem>
			</itemizedlist>

			<para>
				Guard classes subclass <literal>com.espertech.esper.pattern.guard.GuardSupport</literal> as shown here:
			</para>
			<programlisting><![CDATA[public abstract class GuardSupport implements Guard { ...]]></programlisting>

			<para>
				The engine invokes the guard factory class to construct an instance of the guard class for each new sub-expression instance within a statement.
			</para>

			<para>
				A guard class must provide an implementation of the <literal>startGuard</literal> method that the pattern engine invokes to start a guard instance. In our example, the method resets the guard's counter to zero:
			</para>
			<programlisting><![CDATA[public void startGuard() {
  counter = 0;
}]]></programlisting>

			<para>
				The pattern engine invokes the <literal>inspect</literal> method for each time the sub-expression indicates a new event result. Our example guard needs to count the number of events matched, and quit if the maximum number is reached:
			</para>
			<programlisting><![CDATA[public boolean inspect(MatchedEventMap matchEvent) {
  counter++;
  if (counter > numCountTo) {
    quitable.guardQuit();
    return false;
  }
  return true;
}]]></programlisting>

			<para>
				The <literal>inspect</literal> method returns true for events that pass the guard, and false for events that should not pass the guard.
			</para>

		</sect2>

		<sect2 xml:id="custom-pattern-guard-config" revision="1">
			<title>Configuring Guard Namespace and Name</title>
			
			<para>
				The guard factory class name as well as the namespace and name for the new guard must be added to the engine configuration via the configuration API or using the XML configuration file. The configuration shown below is XML however the same options are available through the configuration API:
			</para>
		
			<programlisting><![CDATA[<esper-configuration
  <plugin-pattern-guard namespace="myplugin" name="count_to" 
      factory-class="com.espertech.esper.regression.client.MyCountToPatternGuardFactory"/>
</esper-configuration>]]></programlisting>

			<para>
				The new guard is now ready to use in a statement. The next pattern statement detects the first 10 MyEvent events:
			</para>		
			<programlisting><![CDATA[select * from pattern [(every MyEvent) where myplugin:count_to(10)]]]></programlisting>

			<para>
				Note that the <literal>every</literal> keyword was placed within parentheses to ensure the guard controls the repeated matching of events.
			</para>		

		</sect2>
	</sect1>

    <sect1 xml:id="custom-pattern-observer" revision="1">
        <title>Pattern Observer</title>
        
		<indexterm><primary>plug-in</primary><secondary>custom pattern observer</secondary></indexterm>
		<indexterm><primary>pattern observer</primary><secondary>custom plug-in</secondary></indexterm>

        <para>
			Pattern observers are pattern objects that are executed as part of a pattern expression and can observe events or test conditions. Examples for built-in observers are <literal>timer:at</literal> and <literal>timer:interval</literal>. Some suggested uses of observer objects are: 
        </para>
		<itemizedlist spacing="compact">
			<listitem>
				<para>
					Implement custom scheduling logic using the engine's own scheduling and timer services
				</para>
			</listitem>
			<listitem>
				<para>
					Test conditions related to prior events matching an expression
				</para>
			</listitem>
		</itemizedlist>
        
        <para>
			The following steps are required to develop and use a custom observer object within pattern statements: 
        </para>
			
		<orderedlist spacing="compact">
			<listitem>
				<para>
					Implement an observer factory class, responsible for creating observer object instances.
				</para>
			</listitem>
			<listitem>
				<para>
					Implement an observer class.
				</para>
			</listitem>
			<listitem>
				<para>
					Register an observer factory class with the engine by supplying a namespace and name, via the engine configuration file or the configuration API.
				</para>
			</listitem>
		</orderedlist>

        <para>
			The code for the example observer object as shown in this chapter can be found in the test source folder in package <literal>com.espertech.esper.regression.client</literal> by the name <literal>MyFileExistsObserver</literal>. The sample observer discussed here very simply checks if a file exists, using the filename supplied by the pattern statement, and via the <literal>java.io.File</literal> class.
        </para>

		<sect2 xml:id="custom-pattern-observer-factory-implementing" revision="1">
			<title>Implementing an Observer Factory</title>
			
			<para>
				An observer factory class is responsible for the following functions:
			</para>
			<itemizedlist spacing="compact">
				<listitem>
					<para>
						Implement a <literal>setObserverParameters</literal> method that takes observer parameters, which are themselves expressions.
					</para>
				</listitem>
				<listitem>
					<para>
						Implement a <literal>makeObserver</literal> method that constructs a new observer instance.
					</para>
				</listitem>
			</itemizedlist>

			<para>
				Observer factory classes subclass <literal>com.espertech.esper.pattern.observer.ObserverFactorySupport</literal>:
			</para>
			<programlisting><![CDATA[public class MyFileExistsObserverFactory extends ObserverFactorySupport { ...]]></programlisting>

			<para>
				The engine constructs one instance of the observer factory class for each time the observer is listed in a statement. 
			</para>
				
			<para>
				The observer factory class implements the <literal>setObserverParameters</literal> method that is passed the parameters to the observer as supplied by the statement. It verifies the observer parameters, similar to the code snippet shown next. Our example file-exists observer takes a single string parameter:
			</para>
			<programlisting><![CDATA[public void setObserverParameters(List<ExprNode> expressionParameters, 
			MatchedEventConvertor convertor, ExprValidationContext validationContext) throws ObserverParameterException {
    String message = "File exists observer takes a single string filename parameter";
    if (expressionParameters.size() != 1) {
	    throw new ObserverParameterException(message);
    }
    if (!(expressionParameters.get(0).getExprEvaluator().getType() == String.class)) {
	    throw new ObserverParameterException(message);
    }

    this.filenameExpression = expressionParameters.get(0);
    this.convertor = convertor;
}]]></programlisting>

			<para>
				The pattern engine calls the <literal>makeObserver</literal> method to create a new observer instance. The example <literal>makeObserver</literal> method shown below passes parameters to the observer instance:
			</para>
			<programlisting><![CDATA[public EventObserver makeObserver(PatternAgentInstanceContext context,
			MatchedEventMap beginState, 
			ObserverEventEvaluator observerEventEvaluator, 
			Object stateNodeId, 
			Object observerState) {
    Object filename = PatternExpressionUtil.evaluate("File-exists observer ", beginState, filenameExpression, convertor);
    if (filename == null) {
	    throw new EPException("Filename evaluated to null");
    }

    return new MyFileExistsObserver(beginState, observerEventEvaluator, filename.toString());
}]]></programlisting>

			<para>
				The <literal>ObserverEventEvaluator</literal> parameter allows an observer to indicate events, and to indicate change of truth value to permanently false. Use this interface to indicate when your observer has received or witnessed an event, or changed it's truth value to true or permanently false.
			</para>

			<para>
				The <literal>MatchedEventMap</literal> parameter provides a Map of all matching events for the expression prior to the observer's start. For example, consider a pattern as below:
			</para>
			<programlisting><![CDATA[a=MyEvent -> myplugin:my_observer(...)]]></programlisting>

			<para>
				The above pattern tagged the MyEvent instance with the tag "a". The pattern engine starts an instance of <literal>my_observer</literal> when it receives the first MyEvent. The observer can query the <literal>MatchedEventMap</literal> using  "a" as a key and obtain the tagged event.
			</para>
		</sect2>

		<sect2 xml:id="custom-pattern-observer-implementing" revision="1">
			<title>Implementing an Observer Class</title>
			
			<para>
				An observer class has the following responsibilities:
			</para>
			<itemizedlist spacing="compact">
				<listitem>
					<para>
						Provides a <literal>startObserve</literal> method that starts the observer.
					</para>
				</listitem>
				<listitem>
					<para>
						Provides a <literal>stopObserve</literal> method that stops the observer, called by the engine when the whole pattern is stopped, or the sub-expression containing the observer is stopped.
					</para>
				</listitem>
			</itemizedlist>

			<para>
				Observer classes subclass <literal>com.espertech.esper.pattern.observer.ObserverSupport</literal> as shown here:
			</para>
			<programlisting><![CDATA[public class MyFileExistsObserver implements EventObserver { ...]]></programlisting>

			<para>
				The engine invokes the observer factory class to construct an instance of the observer class for each new sub-expression instance within a statement.
			</para>

			<para>
				An observer class must provide an implementation of the <literal>startObserve</literal> method that the pattern engine invokes to start an observer instance. In our example, the observer checks for the presence of a file and indicates the truth value to the remainder of the expression:
			</para>
			<programlisting><![CDATA[public void startObserve() {
  File file = new File(filename);
  if (file.exists()) {
    observerEventEvaluator.observerEvaluateTrue(beginState);
  } 
  else {
    observerEventEvaluator.observerEvaluateFalse(); 
  }
}]]></programlisting>

			<para>
				Note the observer passes the <literal>ObserverEventEvaluator</literal> an instance of <literal>MatchedEventMap</literal>. The observer can also create one or more new events and pass these events through the Map to the remaining expressions in the pattern.
			</para>

		</sect2>

		<sect2 xml:id="custom-pattern-observer-config" revision="1">
			<title>Configuring Observer Namespace and Name</title>
			
			<para>
				The observer factory class name as well as the namespace and name for the new observer must be added to the engine configuration via the configuration API or using the XML configuration file. The configuration shown below is XML however the same options are available through the configuration API:
			</para>
		
			<programlisting><![CDATA[<esper-configuration
  <plugin-pattern-observer namespace="myplugin" name="file_exists" 
    factory-class="com.espertech.esper.regression.client.MyFileExistsObserverFactory" />
</esper-configuration>]]></programlisting>

			<para>
				The new observer is now ready to use in a statement. The next pattern statement checks every 10 seconds if the given file exists, and indicates to the listener when the file is found.
			</para>		
			<programlisting><![CDATA[select * from pattern [every timer:interval(10 sec) -> myplugin:file_exists("myfile.txt")]]]></programlisting>

		</sect2>
	</sect1>

    <sect1 xml:id="custom-event-representation" revision="1">
        <title>Event Type and Event Object</title>
        
		<indexterm><primary>plug-in</primary><secondary>custom event object</secondary></indexterm>
		<indexterm><primary>event object</primary><secondary>custom</secondary></indexterm>
		    
		<para>
			Creating a plug-in event representation can be useful under any of these conditions:
		</para>
			
		<itemizedlist spacing="compact">
			<listitem>
				<para>
					Your application has existing Java classes that carry event metadata and event property values and your application does not want to (or cannot) extract or transform such event metadata and event data into one of the built-in event representations (POJO Java objects, Map or XML DOM).
				</para>
			</listitem>
			<listitem>
				<para>
					Your application wants to provide a faster or short-cut access path to event data, for example to access XML event data through a Streaming API for XML (StAX).
				</para>
			</listitem>
			<listitem>
				<para>
					Your application must perform a network lookup or other dynamic resolution of event type and events.
				</para>
			</listitem>
		</itemizedlist>	
		
		<para>
			Note that the classes to plug-in custom event representations are held stable between minor releases, but can be subject to change between major releases. 
		</para>
			
		<para>
			Currently, EsperIO provides the following additional event representations:
		</para>
		<itemizedlist spacing="compact">
			<listitem>
				<para>
					Apache Axiom provides access to XML event data on top of the fast Streaming API for XML (StAX). 
				</para>
			</listitem>
		</itemizedlist>	
		
		<para>
			The source code is available for these and they are therefore excellent examples for how to implement a plug-in event representation.
			Please see the EsperIO documentation for usage details.
		</para>

		<sect2 xml:id="custom-eventrep-overview" revision="1">
			<title>How It Works</title>
			
			<para>
				Your application provides a plug-in event representation as an implementation of the <literal>com.espertech.esper.plugin.PlugInEventRepresentation</literal> interface. It registers the implementation class in the
				<literal>Configuration</literal> and at the same time provides a unique URI. This URI is called the root event representation URI. An example value for a root URI is <literal>type://xml/apacheaxiom/OMNode</literal>. 
			</para>
			
			<para>
				One can register multiple plug-in event representations. Each representation has a root URI. The root URI serves to divide the overall space of different event representations and plays a role in resolving event types and event objects.
			</para>

			<para>
				There are two situations in an Esper engine instance asks an event representation for an event type:
			</para>
			<orderedlist>
				<listitem>
					<para>
						When an application registers a new event type using the method <literal>addPlugInEventType</literal> on <literal>ConfigurationOperations</literal>, either at runtime or at configuration time.
					</para>
				</listitem>
				<listitem>
					<para>
						When an EPL statement is created with a new event type name (a name not seen before) and the URIs for resolving such names are set beforehand via <literal>setPlugInEventTypeNameResolutionURIs</literal> on <literal>ConfigurationOperations</literal>.
					</para>
				</listitem>
			</orderedlist>
				
			<para>
				The implementation of the <literal>PlugInEventRepresentation</literal> interface must provide implementations for two key interfaces: <literal>com.espertech.esper.client.EventType</literal> and <literal>EventBean</literal>. It must also implement several other related interfaces as described below.
			</para>

			<para>
				The <literal>EventType</literal> methods provide event metadata including property names and property types. They also provide instances of <literal>EventPropertyGetter</literal> for retrieving event property values. Each instance of <literal>EventType</literal> represents a distinct type of event.
			</para>
			
			<para>
				The <literal>EventBean</literal> implementation is the event itself and encapsulates the underlying event object.
			</para>						
		</sect2>

		<sect2 xml:id="custom-eventrep-steps" revision="1">
			<title>Steps</title>
			<para>
				Follow the steps outlined below to process event objects for your event types:
			</para>
				
			<orderedlist spacing="compact">
				<listitem>
					<para>
						Implement the <literal>EventType</literal>, <literal>EventPropertyGetter</literal> and <literal>EventBean</literal> interfaces.
					</para>
				</listitem>
				<listitem>
					<para>
						Implement the <literal>PlugInEventRepresentation</literal> interface, the <literal>PlugInEventTypeHandler</literal> and <literal>PlugInEventBeanFactory</literal> interfaces, then add the <literal>PlugInEventRepresentation</literal> class name to configuration.
					</para>
				</listitem>
				<listitem>
					<para>
						Register plug-in event types, and/or set the event type name resolution URIs, via configuration.
					</para>
				</listitem>
				<listitem>
					<para>
						Obtain an <literal>EventSender</literal> from <literal>EPRuntime</literal> via the <literal>getEventSender(URI[])</literal> method and use that to send in your event objects.
					</para>
				</listitem>
			</orderedlist>	

			<para>
				Please consult the JavaDoc for further information on each of the interfaces and their respective methods. The Apache Axiom event representation is an example implementation that can be found in the 
				EsperIO packages.
			</para>
		</sect2>				

		<sect2 xml:id="custom-eventrep-uriresolution" revision="1">
			<title>URI-Based Resolution</title>
			
			<para>
				Assume you have registered event representations using the following URIs:
			</para>
				
			<orderedlist spacing="compact">
				<listitem>
					<para>
						type://myFormat/myProject/myName
					</para>
				</listitem>
				<listitem>
					<para>
						type://myFormat/myProject
					</para>
				</listitem>
				<listitem>
					<para>
						type://myFormat/myOtherProject
					</para>
				</listitem>
			</orderedlist>	

			<para>
				When providing an array of child URIs for resolution, the engine compares each child URI to each of the event representation root URIs, in the order provided. Any event representation root URIs that 
				spans the child URI space becomes a candidate event representation. If multiple root URIs match, the order is defined by the more specific root URI first, to the least specific root URI last.
			</para>

			<para>
				During event type resolution and event sender resolution you provide a child URI. Assuming the child URI provided is <literal>type://myFormat/myProject/myName/myEvent?param1=abc&amp;param2=true</literal>. In this example both root URIs #1 (the more specific) and #1 (the less specific) match, while root URI #3 is not a match. Thus at the time of type resolution the engine invokes the <literal>acceptType</literal> method on event presentation for URI #1 first (the more specific), before asking #2 (the less specific) to resolve the type.
			</para>

			<para>			    
				The <literal>EventSender</literal> returned by the <literal>getEventSender(URI[])</literal> method follows the same scheme. The event sender instance asks each matching event representation for each URI to resolve the event object in the order of most specific to least specific root URI, and the first event representation to return an instance of <literal>EventBean</literal> ends the resolution process for event objects.
			</para>

			<para>
				The <literal>type://</literal> part of the URI is an optional convention for the scheme part of an URI that your application may follow. URIs can also be simple names and can include parameters, as the Java software JavaDoc documents for class <literal>java.net.URI</literal>.
			</para>
		</sect2>			
		
		<sect2 xml:id="custom-eventrep-example" revision="1">
				<title>Example</title>
				<para>
					This section implements a minimal sample plug-in event representation. For the sake of keeping the example easy to understand, the event representation is rather straightforward: an event is a <literal>java.util.Properties</literal> object that consists of key-values pairs of type string.
				</para>
				
				<para>
					The code shown next does not document method footprints. Please consult the JavaDoc API documentation for method details.
				</para>

			<sect3 xml:id="custom-eventrep-example-eventtype" revision="1">
				<title>Sample Event Type</title>
				<para>
					First, the sample shows how to implement the <literal>EventType</literal> interface. The event type provides information about property names and types, as well as supertypes of the event type.
				</para>

				<para>
					Our <literal>EventType</literal> takes a set of valid property names:
				</para>
				<programlisting><![CDATA[public class MyPlugInPropertiesEventType implements EventType {
  private final Set<String> properties;

  public MyPlugInPropertiesEventType(Set<String> properties) {
    this.properties = properties;
  }

  public Class getPropertyType(String property) {
    if (!isProperty(property)) {
      return null;
    }
    return String.class;
  }

  public Class getUnderlyingType() {
    return Properties.class;
  }
  
  //... further methods below
}]]></programlisting>

				<para>
					An <literal>EventType</literal> is responsible for providing implementations of <literal>EventPropertyGetter</literal> to query actual events. The getter simply
					queries the <literal>Properties </literal> object underlying each event:
				</para>
				<programlisting><![CDATA[  public EventPropertyGetter getGetter(String property) {
    final String propertyName = property;
    
    return new EventPropertyGetter() {
      public Object get(EventBean eventBean) throws PropertyAccessException {
        MyPlugInPropertiesEventBean propBean = (MyPlugInPropertiesEventBean) eventBean;
        return propBean.getProperties().getProperty(propertyName);
      }
      
      public boolean isExistsProperty(EventBean eventBean) {
        MyPlugInPropertiesEventBean propBean = (MyPlugInPropertiesEventBean) eventBean;
        return propBean.getProperties().getProperty(propertyName) != null;
      }
      
      public Object getFragment(EventBean eventBean) {
	    return null;	// The property is not a fragment
      }
    };
  }]]></programlisting>

				<para>
				  Our sample <literal>EventType</literal> does not have supertypes. Supertypes represent an extends-relationship between event types, and subtypes are expected to exhibit the same event property names and types as each of their supertypes combined:
				</para>
				<programlisting><![CDATA[  public EventType[] getSuperTypes() {
    return null;	// no supertype for this example
  }

  public Iterator<EventType> getDeepSuperTypes() {
    return null;
  }
  
  public String getName() {
    return name;
  }

  public EventPropertyDescriptor[] getPropertyDescriptors() {
    Collection<EventPropertyDescriptor> descriptorColl = descriptors.values();
    return descriptorColl.toArray(new EventPropertyDescriptor[descriptors.size()]);
  }

  public EventPropertyDescriptor getPropertyDescriptor(String propertyName) {
    return descriptors.get(propertyName);
  }

  public FragmentEventType getFragmentType(String property) {
    return null;  // sample does not provide any fragments
  }]]></programlisting>
  
		  <para>
			The example event type as above does not provide fragments, which are properties of the event that can themselves be represented as an event, to keep the example simple.
		  </para>
		  
		  </sect3>

			<sect3 xml:id="custom-eventrep-example-eventbean" revision="1">
				<title>Sample Event Bean</title>
				<para>
					Each <literal>EventBean</literal> instance represents an event. The interface is straightforward to implement. In this example an event is backed by a <literal>Properties</literal> object:
				</para>

				<programlisting><![CDATA[public class MyPlugInPropertiesEventBean implements EventBean {
  private final MyPlugInPropertiesEventType eventType;
  private final Properties properties;

  public MyPlugInPropertiesEventBean(MyPlugInPropertiesEventType eventType, 
        Properties properties) {
    this.eventType = eventType;
    this.properties = properties;
  }

  public EventType getEventType() {
    return eventType;
  }

  public Object get(String property) throws PropertyAccessException {
    EventPropertyGetter getter = eventType.getGetter(property);
    return getter.get(this);
  }

  public Object getFragment(String property) {
    EventPropertyGetter getter = eventType.getGetter(property);
    if (getter != null) {
      return getter.getFragment(this);
    }
    return null;
  }

  public Object getUnderlying() {
    return properties;
  }

  protected Properties getProperties() {
    return properties;
  }    
}]]></programlisting>
		  </sect3>

			<sect3 xml:id="custom-eventrep-example-eventrep" revision="1">
				<title>Sample Event Representation</title>
				<para>
					A <literal>PlugInEventRepresentation</literal> serves to create <literal>EventType</literal> and <literal>EventBean</literal> instances through its related interfaces.
				</para>

				<para>
					The sample event representation creates <literal>MyPlugInPropertiesEventType</literal> and <literal>MyPlugInPropertiesEventBean</literal> instances. 
					The <literal>PlugInEventTypeHandler</literal> returns the <literal>EventType</literal> instance and an <literal>EventSender</literal> instance.
				</para>

				<para>
					Our sample event representation accepts all requests for event types by returning boolean true on the <literal>acceptType</literal> method.  When asked for the <literal>PlugInEventTypeHandler</literal>, it constructs a new <literal>EventType</literal>. The list of property names for the new type is passed as an initialization value provided through the configuration API or XML, as a comma-separated list of property names:
				</para>

				<programlisting><![CDATA[public class MyPlugInEventRepresentation implements PlugInEventRepresentation {

  private List<MyPlugInPropertiesEventType> types;

  public void init(PlugInEventRepresentationContext context) {
    types = new ArrayList<MyPlugInPropertiesEventType>();
  }

  public boolean acceptsType(PlugInEventTypeHandlerContext context) {
    return true;
  }

  public PlugInEventTypeHandler getTypeHandler(PlugInEventTypeHandlerContext eventTypeContext) {
    String proplist = (String) eventTypeContext.getTypeInitializer();
    String[] propertyList = proplist.split(",");

    Set<String> typeProps = new HashSet<String>(Arrays.asList(propertyList));

    MyPlugInPropertiesEventType eventType = new MyPlugInPropertiesEventType(typeProps);
    types.add(eventType);

    return new MyPlugInPropertiesEventTypeHandler(eventType);
  }
  // ... more methods below
}]]></programlisting>

				<para>
					The <literal>PlugInEventTypeHandler</literal> simply returns the <literal>EventType</literal> as well as an implementation of <literal>EventSender</literal> for processing same-type events:
				</para>

				<programlisting><![CDATA[public class MyPlugInPropertiesEventTypeHandler implements PlugInEventTypeHandler {
  private final MyPlugInPropertiesEventType eventType;

  public MyPlugInPropertiesEventTypeHandler(MyPlugInPropertiesEventType eventType) {
    this.eventType = eventType;
  }

  public EventSender getSender(EPRuntimeEventSender runtimeEventSender) {
    return new MyPlugInPropertiesEventSender(eventType, runtimeEventSender);
  }

  public EventType getType() {
    return eventType;
  }
}]]></programlisting>

				<para>
					The <literal>EventSender</literal> returned by <literal>PlugInEventTypeHandler</literal> is expected process events of the same type or any subtype:
				</para>

				<programlisting><![CDATA[public class MyPlugInPropertiesEventSender implements EventSender {
  private final MyPlugInPropertiesEventType type;
  private final EPRuntimeEventSender runtimeSender;

  public MyPlugInPropertiesEventSender(MyPlugInPropertiesEventType type, 
        EPRuntimeEventSender runtimeSender) {
    this.type = type;
    this.runtimeSender = runtimeSender;
  }

  public void sendEvent(Object event) {
    if (!(event instanceof Properties)) {
       throw new EPException("Sender expects a properties event");
    }
    EventBean eventBean = new MyPlugInPropertiesEventBean(type, (Properties) event);
    runtimeSender.processWrappedEvent(eventBean);
  }
}]]></programlisting>
		  </sect3>

			<sect3 xml:id="custom-eventrep-example-eventbeanfac" revision="1">
				<title>Sample Event Bean Factory</title>
				<para>
					The plug-in event representation may optionally provide an implementation of <literal>PlugInEventBeanFactory</literal>. A <literal>PlugInEventBeanFactory</literal> may inspect event objects and assign an event type dynamically based on resolution URIs and event properties.
				</para>
				
				<para>
					Our sample event representation accepts all URIs and returns a <literal>MyPlugInPropertiesBeanFactory</literal>:
				</para>
				<programlisting><![CDATA[public class MyPlugInEventRepresentation implements PlugInEventRepresentation {

  // ... methods as seen earlier
  public boolean acceptsEventBeanResolution(
        PlugInEventBeanReflectorContext eventBeanContext) {
    return true;
  }

  public PlugInEventBeanFactory getEventBeanFactory(
        PlugInEventBeanReflectorContext eventBeanContext) {
    return new MyPlugInPropertiesBeanFactory(types);
   }
}]]></programlisting>

			<para>
			  Last, the sample <literal>MyPlugInPropertiesBeanFactory</literal> implements the <literal>PlugInEventBeanFactory</literal> interface. It inspects incoming events and determines
			  an event type based on whether all properties for that event type are present:
			</para>
			
				<programlisting><![CDATA[public class MyPlugInPropertiesBeanFactory implements PlugInEventBeanFactory {
  private final List<MyPlugInPropertiesEventType> knownTypes;

  public MyPlugInPropertiesBeanFactory(List<MyPlugInPropertiesEventType> types) {
    knownTypes = types;
  }

  public EventBean create(Object event, URI resolutionURI) {
    Properties properties = (Properties) event;

    // use the known types to determine the type of the object
    for (MyPlugInPropertiesEventType type : knownTypes) {
      // if there is one property the event does not contain, then its not the right type
      boolean hasAllProperties = true;
      for (String prop : type.getPropertyNames()) {
        if (!properties.containsKey(prop)) {
          hasAllProperties = false;
          break;
        }
      }

      if (hasAllProperties) {
        return new MyPlugInPropertiesEventBean(type, properties);
      }
    }
    return null; // none match, unknown event
  }
}]]></programlisting>

			</sect3>
		</sect2>			
		
	</sect1>
</chapter>
