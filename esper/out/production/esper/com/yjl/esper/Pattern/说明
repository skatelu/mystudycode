假设事件传入引擎的顺序是这样的：

A1 B1 C1 B2 A2 D1 A3 B3 E1 A4 F1 B4

注意：every优先级高于->，但是圆括号优先级高于所有操作符

Pattern 1:
every ( A -> B )

匹配结果：
{A1, B1}
{A2, B3}
{A4, B4}

说明：因为有括号，所以every针对的是每一个A->B。A2后面的B3到达前，出现了A3，但是B3到达后并未匹配A3，说明every只有在一个完整的匹配发生后再对A进行新的监听，因此A3不会被监听。比如说：A1 A2 A3 A4 B1这样的发生顺序只会导致A1->B1

Pattern 2:
every A -> B

匹配结果：
{A1, B1}
{A2, B3} {A3, B3}
{A4, B4}

说明：由于没有括号，所以every的优先级大于->，所以every针对的是A，而不是A->B。也就是说，引擎每进入一个A，every都为其新建一个pattern实例等待B事件的发生。所以可以从结果中可以看出，B3进入引擎后同时触发了A2和A3

Pattern 3:
A -> every B

匹配结果：
{A1, B1}
{A1, B2}
{A1, B3}
{A1, B4}

说明：every的优先级大于->，且every只作用于B，所以->只会针对第一个A事件起作用，并且每一个B都可以匹配这个A。

Pattern 4:
every A -> every B

匹配结果：
{A1, B1}
{A1, B2}
{A1, B3} {A2, B3} {A3, B3}
{A1, B4} {A2, B4} {A3, B4} {A4, B4}

说明：A和B都用every修饰，every的优先级大于->，所以针对每一个A和B都可以匹配->。再说得通俗一点，只要A在B前进入引擎，那么A后面的B都可以和这个A匹配成功。
